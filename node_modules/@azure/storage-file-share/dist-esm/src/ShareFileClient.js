// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator } from "tslib";
import * as fs from "fs";
import { isNode } from "@azure/core-http";
import { CanonicalCode } from "@azure/core-tracing";
import { FileDownloadResponse } from "./FileDownloadResponse";
import { File } from "./generated/src/operations";
import { rangeToString } from "./Range";
import { fileAttributesToString, fileCreationTimeToString, fileLastWriteTimeToString, validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions, validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions } from "./models";
import { newPipeline, Pipeline } from "./Pipeline";
import { StorageClient } from "./StorageClient";
import { DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, FILE_MAX_SIZE_BYTES, FILE_RANGE_MAX_SIZE_BYTES, DEFAULT_HIGH_LEVEL_CONCURRENCY } from "./utils/constants";
import "@azure/core-paging";
import { Credential } from "./credentials/Credential";
import { Batch } from "./utils/Batch";
import { BufferScheduler } from "./utils/BufferScheduler";
import { streamToBuffer } from "./utils/utils.node";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { readStreamToLocalFile, fsStat } from "./utils/utils.node";
import { FileSystemAttributes } from "./FileSystemAttributes";
import { getShareNameAndPathFromUrl } from "./utils/utils.common";
import { createSpan } from "./utils/tracing";
/**
 * A ShareFileClient represents a URL to an Azure Storage file.
 *
 * @export
 * @class ShareFileClient
 */
var ShareFileClient = /** @class */ (function (_super) {
    __extends(ShareFileClient, _super);
    function ShareFileClient(url, credentialOrPipeline, options) {
        var _a;
        var _this = this;
        var pipeline;
        if (credentialOrPipeline instanceof Pipeline) {
            pipeline = credentialOrPipeline;
        }
        else if (credentialOrPipeline instanceof Credential) {
            pipeline = newPipeline(credentialOrPipeline, options);
        }
        else {
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = getShareNameAndPathFromUrl(_this.url), _this._shareName = _a.shareName, _this._path = _a.filePathOrDirectoryPath);
        _this.context = new File(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ShareFileClient.prototype, "shareName", {
        get: function () {
            return this._shareName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShareFileClient.prototype, "path", {
        get: function () {
            return this._path;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new file or replaces a file. Note it only initializes the file with no content.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-file
     *
     * @param {number} size Specifies the maximum size in bytes for the file, up to 1 TB.
     * @param {FileCreateOptions} [options] Options to File Create operation.
     * @returns {Promise<FileCreateResponse>} Response data for the File Create  operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.create = function (size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, attributes;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (size < 0 || size > FILE_MAX_SIZE_BYTES) {
                        throw new RangeError("File size must >= 0 and < " + FILE_MAX_SIZE_BYTES + ".");
                    }
                    options = validateAndSetDefaultsForFileAndDirectoryCreateCommonOptions(options);
                    if (!options.fileAttributes) {
                        attributes = new FileSystemAttributes();
                        attributes.none = true;
                        options.fileAttributes = attributes;
                    }
                    options.fileHttpHeaders = options.fileHttpHeaders || {};
                    return [2 /*return*/, this.context.create(size, fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileHttpHeaders: options.fileHttpHeaders,
                            metadata: options.metadata,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Reads or downloads a file from the system, including its metadata and properties.
     *
     * * In Node.js, data returns in a Readable stream `readableStreamBody`
     * * In browsers, data returns in a promise `blobBody`
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file
     *
     * @param {number} [offset] From which position of the file to download, >= 0
     * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined
     * @param {FileDownloadOptions} [options] Options to File Download operation.
     * @returns {Promise<FileDownloadResponse>} Response data for the File Download operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.download = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, downloadFullFile, res_1, e_1;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-download", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (options.rangeGetContentMD5 && offset === 0 && count === undefined) {
                            throw new RangeError("rangeGetContentMD5 only works with partial data downloading");
                        }
                        downloadFullFile = offset === 0 && !count;
                        return [4 /*yield*/, this.context.download({
                                abortSignal: options.abortSignal,
                                onDownloadProgress: !isNode ? options.onProgress : undefined,
                                range: downloadFullFile ? undefined : rangeToString({ offset: offset, count: count }),
                                rangeGetContentMD5: options.rangeGetContentMD5,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        res_1 = _b.sent();
                        // Return browser response immediately
                        if (!isNode) {
                            return [2 /*return*/, res_1];
                        }
                        // We support retrying when download stream unexpected ends in Node.js runtime
                        // Following code shouldn't be bundled into browser build, however some
                        // bundlers may try to bundle following code and "FileReadResponse.ts".
                        // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
                        // The config is in package.json "browser" field
                        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                            // TODO: Default value or make it a required parameter?
                            options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
                        }
                        if (res_1.contentLength === undefined) {
                            throw new RangeError("File download response doesn't contain valid content length header");
                        }
                        return [2 /*return*/, new FileDownloadResponse(res_1, function (start) { return __awaiter(_this, void 0, void 0, function () {
                                var updatedOptions;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            updatedOptions = {
                                                range: rangeToString({
                                                    count: offset + res_1.contentLength - start,
                                                    offset: start
                                                })
                                            };
                                            return [4 /*yield*/, this.context.download(__assign(__assign({ abortSignal: options.abortSignal }, updatedOptions), { spanOptions: spanOptions }))];
                                        case 1: 
                                        // Debug purpose only
                                        // console.log(
                                        //   `Read from internal stream, range: ${
                                        //     updatedOptions.range
                                        //   }, options: ${JSON.stringify(updatedOptions)}`
                                        // );
                                        return [2 /*return*/, (_a.sent()).readableStreamBody];
                                    }
                                });
                            }); }, offset, res_1.contentLength, {
                                abortSignal: options.abortSignal,
                                maxRetryRequests: options.maxRetryRequests,
                                onProgress: options.onProgress
                            })];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the file. It does not return the content of the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-file-properties
     *
     * @param {FileGetPropertiesOptions} [options] Options to File Get Properties operation.
     * @returns {Promise<FileGetPropertiesResponse>} Response data for the File Get Properties operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.getProperties({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets properties on the file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {FileProperties} [properties] File properties. For file HTTP headers(e.g. Content-Type),
     *                                       if no values are provided, existing HTTP headers will be removed.
     *                                       For other file properties(e.g. fileAttributes), if no values are provided,
     *                                       existing values will be preserved.
     * @returns {Promise<SetPropertiesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setProperties = function (properties) {
        if (properties === void 0) { properties = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setProperties", properties.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    properties = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(properties);
                    properties.fileHttpHeaders = properties.fileHttpHeaders || {};
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(properties.fileAttributes), fileCreationTimeToString(properties.creationTime), fileLastWriteTimeToString(properties.lastWriteTime), {
                            abortSignal: properties.abortSignal,
                            fileHttpHeaders: properties.fileHttpHeaders,
                            filePermission: properties.filePermission,
                            filePermissionKey: properties.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Removes the file from the storage account.
     * When a file is successfully deleted, it is immediately removed from the storage
     * account's index and is no longer accessible to clients. The file's data is later
     * removed from the service during garbage collection.
     *
     * Delete File will fail with status code 409 (Conflict) and error code SharingViolation
     * if the file is open on an SMB client.
     *
     * Delete File is not supported on a share snapshot, which is a read-only copy of
     * a share. An attempt to perform this operation on a share snapshot will fail with 400 (InvalidQueryParameterValue)
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-file2
     *
     * @param {FileDeleteOptions} [options] Options to File Delete operation.
     * @returns {Promise<FileDeleteResponse>} Response data for the File Delete operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.deleteMethod({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets HTTP headers on the file.
     *
     * If no option provided, or no value provided for the file HTTP headers in the options,
     * these file HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {fileHttpHeaders} [FileHttpHeaders] File HTTP headers like Content-Type.
     *                                             Provide undefined will remove existing HTTP headers.
     * @param {FileSetHttpHeadersOptions} [options] Options to File Set HTTP Headers operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setHttpHeaders = function (fileHttpHeaders, options) {
        if (fileHttpHeaders === void 0) { fileHttpHeaders = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setHTTPHeaders", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved
                    options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileHttpHeaders: fileHttpHeaders,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Resize file.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-properties
     *
     * @param {number} length Resizes a file to the specified size in bytes.
     *                        If the specified byte value is less than the current size of the file,
     *                        then all ranges above the specified byte value are cleared.
     * @param {FileResizeOptions} [options] Options to File Resize operation.
     * @returns {Promise<FileSetHTTPHeadersResponse>} Response data for the File Set HTTP Headers operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.resize = function (length, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-resize", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (length < 0) {
                        throw new RangeError("Size cannot less than 0 when resizing file.");
                    }
                    // FileAttributes, filePermission, createTime, lastWriteTime will all be preserved.
                    options = validateAndSetDefaultsForFileAndDirectorySetPropertiesCommonOptions(options);
                    return [2 /*return*/, this.context.setHTTPHeaders(fileAttributesToString(options.fileAttributes), fileCreationTimeToString(options.creationTime), fileLastWriteTimeToString(options.lastWriteTime), {
                            abortSignal: options.abortSignal,
                            fileContentLength: length,
                            filePermission: options.filePermission,
                            filePermissionKey: options.filePermissionKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Updates user-defined metadata for the specified file.
     *
     * If no metadata defined in the option parameter, the file
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-file-metadata
     *
     * @param {Metadata} [metadata] If no metadata provided, all existing directory metadata will be removed
     * @param {FileSetMetadataOptions} [options] Options to File Set Metadata operation.
     * @returns {Promise<FileSetMetadataResponse>} Response data for the File Set Metadata operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.setMetadata = function (metadata, options) {
        if (metadata === void 0) { metadata = {}; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.setMetadata({
                            abortSignal: options.abortSignal,
                            metadata: metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Upload a range of bytes to a file. Both the start and count of the
     * range must be specified. The range can be up to 4 MB in size.
     *
     * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param {number} offset Offset position of the destination Azure File to upload.
     * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param {FileUploadRangeOptions} [options={}] Options to File Upload Range operation.
     * @returns {Promise<FileUploadRangeResponse>} Response data for the File Upload Range operation.
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.uploadRange = function (body, offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadRange", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (offset < 0) {
                        throw new RangeError("offset must be >= 0");
                    }
                    if (contentLength <= 0 || contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("contentLength must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    if (contentLength > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("offset must be < " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    return [2 /*return*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "update", contentLength, {
                            abortSignal: options.abortSignal,
                            contentMD5: options.contentMD5,
                            onUploadProgress: options.onProgress,
                            optionalbody: body,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Upload a range of bytes to a file where the contents are read from a another file's URL.
     * The range can be up to 4 MB in size.
     *
     * @param {string} sourceURL Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication.
     * @param {number} sourceOffset The source offset to copy from. Pass 0 to copy from the beginning of source file.
     * @param {number} destOffset Offset of destination file.
     * @param {number} count Number of bytes to be uploaded from source file.
     * @param {FileUploadRangeFromURLOptions} [options={}] Options to configure File - Upload Range from URL operation.
     * @returns {Promise<FileUploadRangeFromURLResponse>}
     * @memberof FileURL
     */
    ShareFileClient.prototype.uploadRangeFromURL = function (sourceURL, sourceOffset, destOffset, count, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadRangeFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (sourceOffset < 0 || destOffset < 0) {
                        throw new RangeError("sourceOffset and destOffset must be >= 0");
                    }
                    if (count <= 0 || count > FILE_RANGE_MAX_SIZE_BYTES) {
                        throw new RangeError("count must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES + " bytes");
                    }
                    return [2 /*return*/, this.context.uploadRangeFromURL(rangeToString({ offset: destOffset, count: count }), sourceURL, rangeToString({ offset: sourceOffset, count: count }), 0, __assign(__assign({ abortSignal: options.abortSignal, sourceModifiedAccessConditions: options.sourceConditions }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Clears the specified range and
     * releases the space used in storage for that range.
     *
     * @param {number} offset
     * @param {number} contentLength
     * @param {FileClearRangeOptions} [options] Options to File Clear Range operation.
     * @returns {Promise<FileUploadRangeResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.clearRange = function (offset, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-clearRange", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (offset < 0 || contentLength <= 0) {
                        throw new RangeError("offset must >= 0 and contentLength must be > 0");
                    }
                    return [2 /*return*/, this.context.uploadRange(rangeToString({ count: contentLength, offset: offset }), "clear", 0, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns the list of valid ranges for a file.
     *
     * @param {FileGetRangeListOptions} [options] Options to File Get range List operation.
     * @returns {Promise<FileGetRangeListResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.getRangeList = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, originalResponse, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-getRangeList", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.context.getRangeList({
                                abortSignal: options.abortSignal,
                                range: options.range ? rangeToString(options.range) : undefined,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        originalResponse = _b.sent();
                        return [2 /*return*/, {
                                _response: originalResponse._response,
                                date: originalResponse.date,
                                etag: originalResponse.etag,
                                errorCode: originalResponse.errorCode,
                                fileContentLength: originalResponse.fileContentLength,
                                lastModified: originalResponse.lastModified,
                                rangeList: originalResponse.filter(function () {
                                    return true;
                                }),
                                requestId: originalResponse.requestId,
                                version: originalResponse.version
                            }];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Copies a blob or file to a destination file within the storage account.
     *
     * @param {string} copySource Specifies the URL of the source file or blob, up to 2 KB in length.
     * To copy a file to another file within the same storage account, you may use Shared Key to
     * authenticate the source file. If you are copying a file from another storage account, or if you
     * are copying a blob from the same storage account or another storage account, then you must
     * authenticate the source file or blob using a shared access signature. If the source is a public
     * blob, no authentication is required to perform the copy operation. A file in a share snapshot
     * can also be specified as a copy source.
     * @param {FileStartCopyOptions} [options] Options to File Start Copy operation.
     * @returns {Promise<FileStartCopyResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.startCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-startCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.startCopy(copySource, {
                            abortSignal: options.abortSignal,
                            metadata: options.metadata,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Aborts a pending Copy File operation, and leaves a destination file with zero length and full
     * metadata.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-file
     *
     * @param {string} copyId Id of the Copy File operation to abort.
     * @param {FileAbortCopyFromURLOptions} [options] Options to File Abort Copy From URL operation.
     * @returns {Promise<FileAbortCopyResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.abortCopyFromURL = function (copyId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-abortCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.context.abortCopy(copyId, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    // High Level functions
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to an Azure File.
     *
     * @param {Blob | ArrayBuffer | ArrayBufferView} browserData Blob, File, ArrayBuffer or ArrayBufferView
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadBrowserData = function (browserData, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, browserBlob_1;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-uploadBrowserData", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    browserBlob_1 = new Blob([browserData]);
                    return [2 /*return*/, this.uploadSeekableBlob(function (offset, size) {
                            return browserBlob_1.slice(offset, offset + size);
                        }, browserBlob_1.size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob object to an Azure file. Requires a blobFactory as the data source,
     * which need to return a Blob object with the offset and size provided.
     *
     * @param {(offset: number, size: number) => Blob} blobFactory
     * @param {number} size
     * @param {FileParallelUploadOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadSeekableBlob = function (blobFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_1, transferProgress_1, batch, _loop_1, i, e_3;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-UploadSeekableBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_1 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_1 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_1 = function (i) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_1 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(blobFactory(start, contentLength), start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            // TODO: Hook with convenience layer progress event in finer level
                                            transferProgress_1 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_1 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_1; i++) {
                            _loop_1(i);
                        }
                        return [2 /*return*/, batch.do()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a local file to an Azure file.
     *
     * @param {string} filePath Full path of local file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    ShareFileClient.prototype.uploadFile = function (filePath, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, size, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, fsStat(filePath)];
                    case 2:
                        size = (_b.sent()).size;
                        return [2 /*return*/, this.uploadResetableStream(function (offset, count) {
                                return fs.createReadStream(filePath, {
                                    autoClose: true,
                                    end: count ? offset + count - 1 : Infinity,
                                    start: offset
                                });
                            }, size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to an Azure File.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the Azure file to be uploaded.
     *
     * @export
     * @param {(offset: number) => NodeJS.ReadableStream} streamFactory Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param {number} size Size of the Azure file
     * @param {ShareFileClient} fileClient ShareFileClient
     * @param {FileParallelUploadOptions} [options]
     * @returns {(Promise<void>)}
     */
    ShareFileClient.prototype.uploadResetableStream = function (streamFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_2, transferProgress_2, batch, _loop_2, i, e_5;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadResetableStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0 || options.rangeSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("options.rangeSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        numBlocks_2 = Math.floor((size - 1) / options.rangeSize) + 1;
                        transferProgress_2 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_2 = function (i) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var start, end, contentLength;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            start = options.rangeSize * i;
                                            end = i === numBlocks_2 - 1 ? size : start + options.rangeSize;
                                            contentLength = end - start;
                                            return [4 /*yield*/, this.uploadRange(function () { return streamFactory(start, contentLength); }, start, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            transferProgress_2 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_2 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_2; i++) {
                            _loop_2(i);
                        }
                        return [2 /*return*/, batch.do()];
                    case 3:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure file in parallel to a buffer.
     * Offset and count are optional, pass 0 for both to download the entire file.
     *
     * @param {Buffer} buffer Buffer to be fill, must have length larger than count
     * @param {number} offset From which position of the Azure File to download
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined
     * @param {FileDownloadToBufferOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.downloadToBuffer = function (buffer, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, transferProgress_3, batch, _loop_3, off, e_6;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToBuffer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        if (!options.rangeSize) {
                            options.rangeSize = FILE_RANGE_MAX_SIZE_BYTES;
                        }
                        if (options.rangeSize < 0) {
                            throw new RangeError("rangeSize option must be > 0");
                        }
                        if (offset < 0) {
                            throw new RangeError("offset option must be >= 0");
                        }
                        if (count && count <= 0) {
                            throw new RangeError("count option must be > 0");
                        }
                        if (!options.concurrency) {
                            options.concurrency = DEFAULT_HIGH_LEVEL_CONCURRENCY;
                        }
                        if (options.concurrency < 0) {
                            throw new RangeError("options.concurrency cannot less than 0.");
                        }
                        if (!!count) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        response = _b.sent();
                        count = response.contentLength - offset;
                        if (count < 0) {
                            throw new RangeError("offset " + offset + " shouldn't be larger than file size " + response.contentLength);
                        }
                        _b.label = 3;
                    case 3:
                        if (buffer.length < count) {
                            throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
                        }
                        transferProgress_3 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_3 = function (off) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var chunkEnd, response, stream;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            chunkEnd = offset + count;
                                            if (off + options.rangeSize < chunkEnd) {
                                                chunkEnd = off + options.rangeSize;
                                            }
                                            return [4 /*yield*/, this.download(off, chunkEnd - off, {
                                                    abortSignal: options.abortSignal,
                                                    maxRetryRequests: options.maxRetryRequestsPerRange,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            response = _a.sent();
                                            stream = response.readableStreamBody;
                                            return [4 /*yield*/, streamToBuffer(stream, buffer, off - offset, chunkEnd - offset)];
                                        case 2:
                                            _a.sent();
                                            // Update progress after block is downloaded, in case of block trying
                                            // Could provide finer grained progress updating inside HTTP requests,
                                            // only if convenience layer download try is enabled
                                            transferProgress_3 += chunkEnd - off;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_3 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (off = offset; off < offset + count; off = off + options.rangeSize) {
                            _loop_3(off);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 4:
                        _b.sent();
                        return [3 /*break*/, 7];
                    case 5:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a Node.js Readable stream into an Azure file.
     * This method will try to create an Azure, then starts uploading chunk by chunk.
     * Size of chunk is defined by `bufferSize` parameter.
     * Please make sure potential size of stream doesn't exceed file size.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *   parameter, which will avoid Buffer.concat() operations.
     *
     * @param {Readable} stream Node.js Readable stream. Must be less or equal than file size.
     * @param {number} size Size of file to be created. Maxium size allowed is 1TB.
     *                      If this value is larger than stream size, there will be empty bytes in file tail.
     * @param {number} bufferSize Size of every buffer allocated in bytes, also the chunk/range size during
     *                            the uploaded file. Size must be > 0 and <= 4 * 1024 * 1024 (4MB)
     * @param {number} maxBuffers Max buffers will allocate during uploading, positive correlation
     *                            with max uploading concurrency
     * @param {FileUploadStreamOptions} [options]
     * @returns {Promise<void>}
     */
    ShareFileClient.prototype.uploadStream = function (stream, size, bufferSize, maxBuffers, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, transferProgress_4, scheduler, e_7;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-uploadStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (!options.fileHttpHeaders) {
                            options.fileHttpHeaders = {};
                        }
                        if (bufferSize <= 0 || bufferSize > FILE_RANGE_MAX_SIZE_BYTES) {
                            throw new RangeError("bufferSize must be > 0 and <= " + FILE_RANGE_MAX_SIZE_BYTES);
                        }
                        if (maxBuffers < 0) {
                            throw new RangeError("maxBuffers must be > 0.");
                        }
                        // Create the file
                        return [4 /*yield*/, this.create(size, {
                                abortSignal: options.abortSignal,
                                fileHttpHeaders: options.fileHttpHeaders,
                                metadata: options.metadata,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        // Create the file
                        _b.sent();
                        transferProgress_4 = 0;
                        scheduler = new BufferScheduler(stream, bufferSize, maxBuffers, function (buffer, offset) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        if (transferProgress_4 + buffer.length > size) {
                                            throw new RangeError("Stream size is larger than file size " + size + " bytes, uploading failed. " +
                                                "Please make sure stream length is less or equal than file size.");
                                        }
                                        return [4 /*yield*/, this.uploadRange(buffer, offset, buffer.length, {
                                                abortSignal: options.abortSignal,
                                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                            })];
                                    case 1:
                                        _a.sent();
                                        // Update progress after block is successfully uploaded to server, in case of block trying
                                        transferProgress_4 += buffer.length;
                                        if (options.onProgress) {
                                            options.onProgress({ loadedBytes: transferProgress_4 });
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 
                        // Concurrency should set a smaller value than maxBuffers, which is helpful to
                        // reduce the possibility when a outgoing handler waits for stream data, in
                        // this situation, outgoing handlers are blocked.
                        // Outgoing queue shouldn't be empty.
                        Math.ceil((maxBuffers / 4) * 3));
                        return [2 /*return*/, scheduler.do()];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param {string} filePath
     * @param {number} [offset] From which position of the block blob to download.
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined.
     * @param {BlobDownloadOptions} [options] Options to Blob download options.
     * @returns {Promise<FileDownloadResponse>} The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     * @memberof BlobClient
     */
    ShareFileClient.prototype.downloadToFile = function (filePath, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-downloadToFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        return [4 /*yield*/, this.download(offset, count, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        response = _b.sent();
                        if (!response.readableStreamBody) return [3 /*break*/, 4];
                        return [4 /*yield*/, readStreamToLocalFile(response.readableStreamBody, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        // The stream is no longer accessible so setting it to undefined.
                        response.fileDownloadStream = undefined;
                        return [2 /*return*/, response];
                    case 5:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Lists handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/list-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options={}]
     * @returns {Promise<FileListHandlesResponse>}
     * @memberof FileURL
     */
    ShareFileClient.prototype.listHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_9;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-listHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        marker = marker === "" ? undefined : marker;
                        return [4 /*yield*/, this.context.listHandles(__assign(__assign({ abortSignal: options.abortSignal, marker: marker }, options), { spanOptions: spanOptions }))];
                    case 2:
                        response = _b.sent();
                        // TODO: Protocol layer issue that when handle list is in returned XML
                        // response.handleList is an empty string
                        if (response.handleList === "") {
                            response.handleList = undefined;
                        }
                        return [2 /*return*/, response];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for FileListHandlesResponse
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of the list to be
     *                          returned with the next list handles operation. The operation returns a
     *                          marker value within the response body if the list returned was not complete.
     *                          The marker value may then be used in a subsequent call to request the next
     *                          set of list items.
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<FileListHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.iterateHandleSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function iterateHandleSegments_1() {
            var listHandlesResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 6];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listHandlesSegment(marker, options))];
                    case 2:
                        listHandlesResponse = _a.sent();
                        marker = listHandlesResponse.continuationToken;
                        return [4 /*yield*/, __await(listHandlesResponse)];
                    case 3: return [4 /*yield*/, _a.sent()];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 6;
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for handles
     *
     * @private
     * @param {FileListHandlesSegmentOptions} [options] Options to list handles operation.
     * @returns {AsyncIterableIterator<HandleItem>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.listHandleItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listHandleItems_1() {
            var marker, _a, _b, listHandlesResponse, _i, _c, handle, e_10_1;
            var e_10, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 9, 10, 15]);
                        _a = __asyncValues(this.iterateHandleSegments(marker, options));
                        _e.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _e.sent(), !_b.done)) return [3 /*break*/, 8];
                        listHandlesResponse = _b.value;
                        if (!listHandlesResponse.handleList) return [3 /*break*/, 7];
                        _i = 0, _c = listHandlesResponse.handleList;
                        _e.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        handle = _c[_i];
                        return [4 /*yield*/, __await(handle)];
                    case 4: return [4 /*yield*/, _e.sent()];
                    case 5:
                        _e.sent();
                        _e.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7: return [3 /*break*/, 1];
                    case 8: return [3 /*break*/, 15];
                    case 9:
                        e_10_1 = _e.sent();
                        e_10 = { error: e_10_1 };
                        return [3 /*break*/, 15];
                    case 10:
                        _e.trys.push([10, , 13, 14]);
                        if (!(_b && !_b.done && (_d = _a.return))) return [3 /*break*/, 12];
                        return [4 /*yield*/, __await(_d.call(_a))];
                    case 11:
                        _e.sent();
                        _e.label = 12;
                    case 12: return [3 /*break*/, 14];
                    case 13:
                        if (e_10) throw e_10.error;
                        return [7 /*endfinally*/];
                    case 14: return [7 /*endfinally*/];
                    case 15: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the handles.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the handles in pages.
     *
     * @param {FileListHandlesOptions} [options] Options to list handles operation.
     * @memberof ShareFileClient
     * @returns {PagedAsyncIterableIterator<HandleItem, FileListHandlesResponse>}
     * An asyncIterableIterator that supports paging.
     */
    ShareFileClient.prototype.listHandles = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        // an AsyncIterableIterator to iterate over handles
        var iter = this.listHandleItems(options);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.iterateHandleSegments(settings.continuationToken, __assign({ maxPageSize: settings.maxPageSize }, options));
            },
            _a;
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} [marker] Optional. A string value that identifies the position of handles that will
     *                          be closed with the next force close handles operation.
     *                          The operation returns a marker value within the response
     *                          body if there are more handles to close. The marker value
     *                          may then be used in a subsequent call to close the next set of handles.
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseHandlesSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-forceCloseHandlesSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    marker = marker === "" ? undefined : marker;
                    return [2 /*return*/, this.context.forceCloseHandles("*", {
                            abortSignal: options.abortSignal,
                            marker: marker,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Force close all handles for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<number>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseAllHandles = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, handlesClosed, marker, response, e_11;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ShareFileClient-forceCloseAllHandles", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 6, 7, 8]);
                        handlesClosed = 0;
                        marker = "";
                        _b.label = 2;
                    case 2: return [4 /*yield*/, this.forceCloseHandlesSegment(marker, { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) })];
                    case 3:
                        response = _b.sent();
                        marker = response.marker;
                        response.numberOfHandlesClosed && (handlesClosed += response.numberOfHandlesClosed);
                        _b.label = 4;
                    case 4:
                        if (marker) return [3 /*break*/, 2];
                        _b.label = 5;
                    case 5: return [2 /*return*/, handlesClosed];
                    case 6:
                        e_11 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_11.message
                        });
                        throw e_11;
                    case 7:
                        span.end();
                        return [7 /*endfinally*/];
                    case 8: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Force close a specific handle for a file.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/force-close-handles
     *
     * @param {string} handleId Specific handle ID, cannot be asterisk "*".
     *                          Use forceCloseAllHandles() to close all handles.
     * @param {FileForceCloseHandlesOptions} [options] Options to force close handles operation.
     * @returns {Promise<FileForceCloseHandlesResponse>}
     * @memberof ShareFileClient
     */
    ShareFileClient.prototype.forceCloseHandle = function (handleId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ShareFileClient-forceCloseHandle", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    if (handleId === "*") {
                        throw new RangeError("Parameter handleID should be a specified handle ID. Use forceCloseHandlesSegment() to close all handles.");
                    }
                    return [2 /*return*/, this.context.forceCloseHandles(handleId, {
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return ShareFileClient;
}(StorageClient));
export { ShareFileClient };
//# sourceMappingURL=ShareFileClient.js.map