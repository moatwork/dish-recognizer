// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter, __extends, __generator, __values } from "tslib";
import { isTokenCredential, isNode, getDefaultProxySettings } from "@azure/core-http";
import { CanonicalCode } from "@azure/core-tracing";
import { Container } from "./generated/src/operations";
import { DevelopmentConnectionString } from "./utils/constants";
import { newPipeline, Pipeline } from "./Pipeline";
import { ETagNone } from "./utils/constants";
import { appendToURLPath, truncatedISO8061Date, extractConnectionStringParts, getValueInConnString } from "./utils/utils.common";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { BlobLeaseClient } from "./BlobLeaseClient";
import "@azure/core-paging";
import { createSpan } from "./utils/tracing";
import { StorageClient } from "./StorageClient";
import { BlobClient, AppendBlobClient, BlockBlobClient, PageBlobClient } from "./BlobClient";
/**
 * A ContainerClient represents a URL to the Azure Storage container allowing you to manipulate its blobs.
 *
 * @export
 * @class ContainerClient
 */
var ContainerClient = /** @class */ (function (_super) {
    __extends(ContainerClient, _super);
    function ContainerClient(urlOrConnectionString, credentialOrPipelineOrContainerName, options) {
        var _this = this;
        var pipeline;
        var url;
        options = options || {};
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            var containerName = credentialOrPipelineOrContainerName;
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(extractedCreds.url, encodeURIComponent(containerName));
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url =
                    appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)) +
                        "?" +
                        extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName parameter");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this._containerName = _this.getContainerNameFromUrl();
        _this.containerContext = new Container(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(ContainerClient.prototype, "containerName", {
        /**
         * The name of the container.
         */
        get: function () {
            return this._containerName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new container under the specified account. If the container with
     * the same name already exists, the operation fails.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/create-container
     *
     * @param {ContainerCreateOptions} [options] Options to Container Create operation.
     * @returns {Promise<ContainerCreateResponse>}
     * @memberof ContainerClient
     *
     * @example
     * ```js
     * const containerClient = blobServiceClient.getContainerClient("<container name>");
     * const createContainerResponse = await containerClient.create();
     * console.log("Container was created successfully", createContainerResponse.requestId);
     * ```
     */
    ContainerClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ContainerClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    // Spread operator in destructuring assignments,
                    // this will filter out unwanted properties from the response object into result object
                    return [2 /*return*/, this.containerContext.create(__assign(__assign({}, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns true if the Azrue container resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing container might be deleted by other clients or
     * applications. Vice versa new containers with the same name might be added by other clients or
     * applications after this function completes.
     *
     * @param {ContainerExistsOptions} [options={}]
     * @returns {Promise<boolean>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ContainerClient-exists", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_1 = _b.sent();
                        if (e_1.statusCode === 404) {
                            span.setStatus({
                                code: CanonicalCode.NOT_FOUND,
                                message: "Expected exception when checking container existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Creates a {@link BlobClient}
     *
     * @param {string} blobName A blob name
     * @returns {BlobClient} A new BlobClient object for the given blob name.
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getBlobClient = function (blobName) {
        return new BlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
    };
    /**
     * Creates an {@link AppendBlobClient}
     *
     * @param {string} blobName An append blob name
     * @returns {AppendBlobClient}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getAppendBlobClient = function (blobName) {
        return new AppendBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
    };
    /**
     * Creates a {@link BlockBlobClient}
     *
     * @param {string} blobName A block blob name
     * @returns {BlockBlobClient}
     * @memberof ContainerClient
     *
     * @example
     * ```js
     * const content = "Hello world!";
     *
     * const blockBlobClient = containerClient.getBlockBlobClient("<blob name>");
     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
     * ```
     */
    ContainerClient.prototype.getBlockBlobClient = function (blobName) {
        return new BlockBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
    };
    /**
     * Creates a {@link PageBlobClient}
     *
     * @param {string} blobName A page blob name
     * @returns {PageBlobClient}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getPageBlobClient = function (blobName) {
        return new PageBlobClient(appendToURLPath(this.url, encodeURIComponent(blobName)), this.pipeline);
    };
    /**
     * Returns all user-defined metadata and system properties for the specified
     * container. The data returned does not include the container's list of blobs.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-properties
     *
     * @param {ContainerGetPropertiesOptions} [options] Options to Container Get Properties operation.
     * @returns {Promise<ContainerGetPropertiesResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                if (!options.conditions) {
                    options.conditions = {};
                }
                _a = createSpan("ContainerClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.containerContext.getProperties(__assign(__assign({ abortSignal: options.abortSignal }, options.conditions), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Marks the specified container for deletion. The container and any blobs
     * contained within it are later deleted during garbage collection.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-container
     *
     * @param {ContainerDeleteMethodOptions} [options] Options to Container Delete operation.
     * @returns {Promise<ContainerDeleteResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                if (!options.conditions) {
                    options.conditions = {};
                }
                if ((options.conditions.ifMatch && options.conditions.ifMatch !== ETagNone) ||
                    (options.conditions.ifNoneMatch && options.conditions.ifNoneMatch !== ETagNone)) {
                    throw new RangeError("the IfMatch and IfNoneMatch access conditions must have their default\
        values because they are ignored by the service");
                }
                _a = createSpan("ContainerClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.containerContext.deleteMethod({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets one or more user-defined name-value pairs for the specified container.
     *
     * If no option provided, or no metadata defined in the parameter, the container
     * metadata will be removed.
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-metadata
     *
     * @param {Metadata} [metadata] Replace existing metadata with this value.
     *                            If no value provided the existing metadata will be removed.
     * @param {ContainerSetMetadataOptions} [options] Options to Container Set Metadata operation.
     * @returns {Promise<ContainerSetMetadataResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                if (!options.conditions) {
                    options.conditions = {};
                }
                if (options.conditions.ifUnmodifiedSince ||
                    (options.conditions.ifMatch && options.conditions.ifMatch !== ETagNone) ||
                    (options.conditions.ifNoneMatch && options.conditions.ifNoneMatch !== ETagNone)) {
                    throw new RangeError("the IfUnmodifiedSince, IfMatch, and IfNoneMatch must have their default values\
        because they are ignored by the blob service");
                }
                _a = createSpan("ContainerClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.containerContext.setMetadata({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            metadata: metadata,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets the permissions for the specified container. The permissions indicate
     * whether container data may be accessed publicly.
     *
     * WARNING: JavaScript Date will potentially lose precision when parsing startsOn and expiresOn strings.
     * For example, new Date("2018-12-31T03:44:23.8827891Z").toISOString() will get "2018-12-31T03:44:23.882Z".
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-container-acl
     *
     * @param {ContainerGetAccessPolicyOptions} [options] Options to Container Get Access Policy operation.
     * @returns {Promise<ContainerGetAccessPolicyResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getAccessPolicy = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, res, _i, response_1, identifier, accessPolicy, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!options.conditions) {
                            options.conditions = {};
                        }
                        _a = createSpan("ContainerClient-getAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.containerContext.getAccessPolicy({
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.conditions,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        response = _b.sent();
                        res = {
                            _response: response._response,
                            blobPublicAccess: response.blobPublicAccess,
                            date: response.date,
                            etag: response.etag,
                            errorCode: response.errorCode,
                            lastModified: response.lastModified,
                            requestId: response.requestId,
                            clientRequestId: response.clientRequestId,
                            signedIdentifiers: [],
                            version: response.version
                        };
                        for (_i = 0, response_1 = response; _i < response_1.length; _i++) {
                            identifier = response_1[_i];
                            accessPolicy = {
                                permissions: identifier.accessPolicy.permissions
                            };
                            if (identifier.accessPolicy.expiresOn) {
                                accessPolicy.expiresOn = new Date(identifier.accessPolicy.expiresOn);
                            }
                            if (identifier.accessPolicy.startsOn) {
                                accessPolicy.startsOn = new Date(identifier.accessPolicy.startsOn);
                            }
                            res.signedIdentifiers.push({
                                accessPolicy: accessPolicy,
                                id: identifier.id
                            });
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_2 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Sets the permissions for the specified container. The permissions indicate
     * whether blobs in a container may be accessed publicly.
     *
     * When you set permissions for a container, the existing permissions are replaced.
     * If no access or containerAcl provided, the existing container ACL will be
     * removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-container-acl
     *
     * @param {PublicAccessType} [access] The level of public access to data in the container.
     * @param {SignedIdentifier[]} [containerAcl] Array of elements each having a unique Id and details of the access policy.
     * @param {ContainerSetAccessPolicyOptions} [options] Options to Container Set Access Policy operation.
     * @returns {Promise<ContainerSetAccessPolicyResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.setAccessPolicy = function (access, containerAcl, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, acl, _i, _b, identifier;
            return __generator(this, function (_c) {
                options.conditions = options.conditions || {};
                _a = createSpan("ContainerClient-setAccessPolicy", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    acl = [];
                    for (_i = 0, _b = containerAcl || []; _i < _b.length; _i++) {
                        identifier = _b[_i];
                        acl.push({
                            accessPolicy: {
                                expiresOn: identifier.accessPolicy.expiresOn
                                    ? truncatedISO8061Date(identifier.accessPolicy.expiresOn)
                                    : "",
                                permissions: identifier.accessPolicy.permissions,
                                startsOn: identifier.accessPolicy.startsOn
                                    ? truncatedISO8061Date(identifier.accessPolicy.startsOn)
                                    : ""
                            },
                            id: identifier.id
                        });
                    }
                    return [2 /*return*/, this.containerContext.setAccessPolicy({
                            abortSignal: options.abortSignal,
                            access: access,
                            containerAcl: acl,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Get a {@link BlobLeaseClient} that manages leases on the container.
     *
     * @param {string} [proposeLeaseId] Initial proposed lease Id.
     * @returns {BlobLeaseClient} A new BlobLeaseClient object for managing leases on the container.
     * @memberof ContainerClient
     */
    ContainerClient.prototype.getBlobLeaseClient = function (proposeLeaseId) {
        return new BlobLeaseClient(this, proposeLeaseId);
    };
    /**
     * Creates a new block blob, or updates the content of an existing block blob.
     *
     * Updating an existing block blob overwrites any existing metadata on the blob.
     * Partial updates are not supported; the content of the existing blob is
     * overwritten with the new content. To perform a partial update of a block blob's,
     * use {@link BlockBlobClient.stageBlock} and {@link BlockBlobClient.commitBlockList}.
     *
     * This is a non-parallel uploading method, please use {@link BlockBlobClient.uploadFile},
     * {@link BlockBlobClient.uploadStream} or {@link BlockBlobClient.uploadBrowserData} for better
     * performance with concurrency uploading.
     *
     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param {string} blobName Name of the block blob to create or update.
     * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param {BlockBlobUploadOptions} [options] Options to configure the Block Blob Upload operation.
     * @returns {Promise<{ blockBlobClient: BlockBlobClient; response: BlockBlobUploadResponse }>} Block Blob upload response data and the corresponding BlockBlobClient instance.
     * @memberof ContainerClient
     */
    ContainerClient.prototype.uploadBlockBlob = function (blobName, body, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, blockBlobClient, response, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ContainerClient-uploadBlockBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        blockBlobClient = this.getBlockBlobClient(blobName);
                        return [4 /*yield*/, blockBlobClient.upload(body, contentLength, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        response = _b.sent();
                        return [2 /*return*/, {
                                blockBlobClient: blockBlobClient,
                                response: response
                            }];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Marks the specified blob or snapshot for deletion. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob
     *
     * @param {string} blobName
     * @param {BlobDeleteOptions} [options] Options to Blob Delete operation.
     * @returns {Promise<BlobDeleteResponse>} Block blob deletion response data.
     * @memberof ContainerClient
     */
    ContainerClient.prototype.deleteBlob = function (blobName, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, blobClient, e_4;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("ContainerClient-deleteBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        blobClient = this.getBlobClient(blobName);
                        return [4 /*yield*/, blobClient.delete(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * listBlobFlatSegment returns a single segment of blobs starting from the
     * specified Marker. Use an empty Marker to start enumeration from the beginning.
     * After getting a segment, process it, and then call listBlobsFlatSegment again
     * (passing the the previously-returned Marker) to get the next segment.
     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.
     * @param {ContainerListBlobsSegmentOptions} [options] Options to Container List Blob Flat Segment operation.
     * @returns {Promise<ContainerListBlobFlatSegmentResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listBlobFlatSegment = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ContainerClient-listBlobFlatSegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.containerContext.listBlobFlatSegment(__assign(__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * listBlobHierarchySegment returns a single segment of blobs starting from
     * the specified Marker. Use an empty Marker to start enumeration from the
     * beginning. After getting a segment, process it, and then call listBlobsHierarchicalSegment
     * again (passing the the previously-returned Marker) to get the next segment.
     * @see https://docs.microsoft.com/rest/api/storageservices/list-blobs
     *
     * @param {string} delimiter The charactor or string used to define the virtual hierarchy
     * @param {string} [marker] A string value that identifies the portion of the list to be returned with the next list operation.
     * @param {ContainerListBlobsSegmentOptions} [options] Options to Container List Blob Hierarchy Segment operation.
     * @returns {Promise<ContainerListBlobHierarchySegmentResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listBlobHierarchySegment = function (delimiter, marker, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("ContainerClient-listBlobHierarchySegment", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.containerContext.listBlobHierarchySegment(delimiter, __assign(__assign({ marker: marker }, options), { spanOptions: spanOptions }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobFlatSegmentResponse
     *
     * @private
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {ContainerListBlobsSegmentOptions} [options] Options to list blobs operation.
     * @returns {AsyncIterableIterator<ContainerListBlobFlatSegmentResponse>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listSegments = function (marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listSegments_1() {
            var listBlobsFlatSegmentResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listBlobFlatSegment(marker, options))];
                    case 2:
                        listBlobsFlatSegmentResponse = _a.sent();
                        marker = listBlobsFlatSegmentResponse.continuationToken;
                        return [4 /*yield*/, __await(listBlobsFlatSegmentResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator of {@link BlobItem} objects
     *
     * @private
     * @param {ContainerListBlobsSegmentOptions} [options] Options to list blobs operation.
     * @returns {AsyncIterableIterator<BlobItem>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listItems = function (options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listItems_1() {
            var marker, _a, _b, listBlobsFlatSegmentResponse, e_5_1;
            var e_5, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _d.trys.push([0, 7, 8, 13]);
                        _a = __asyncValues(this.listSegments(marker, options));
                        _d.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _d.sent(), !_b.done)) return [3 /*break*/, 6];
                        listBlobsFlatSegmentResponse = _b.value;
                        return [5 /*yield**/, __values(__asyncDelegator(__asyncValues(listBlobsFlatSegmentResponse.segment.blobItems)))];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_d.sent()])];
                    case 4:
                        _d.sent();
                        _d.label = 5;
                    case 5: return [3 /*break*/, 1];
                    case 6: return [3 /*break*/, 13];
                    case 7:
                        e_5_1 = _d.sent();
                        e_5 = { error: e_5_1 };
                        return [3 /*break*/, 13];
                    case 8:
                        _d.trys.push([8, , 11, 12]);
                        if (!(_b && !_b.done && (_c = _a.return))) return [3 /*break*/, 10];
                        return [4 /*yield*/, __await(_c.call(_a))];
                    case 9:
                        _d.sent();
                        _d.label = 10;
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        if (e_5) throw e_5.error;
                        return [7 /*endfinally*/];
                    case 12: return [7 /*endfinally*/];
                    case 13: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the blobs
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs in pages.
     *
     * // Get the containerClient before you run these snippets,
     * // Can be obtained from `blobServiceClient.getContainerClient("<your-container-name>");`
     * @example
     * ```js
     *   let i = 1;
     *   for await (const blob of containerClient.listBlobsFlat()) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Generator syntax .next()
     *   let i = 1;
     *   let iter = containerClient.listBlobsFlat();
     *   let blobItem = await iter.next();
     *   while (!blobItem.done) {
     *     console.log(`Blob ${i++}: ${blobItem.value.name}`);
     *     blobItem = await iter.next();
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Example for .byPage()
     *   // passing optional maxPageSize in the page settings
     *   let i = 1;
     *   for await (const response of containerClient.listBlobsFlat().byPage({ maxPageSize: 20 })) {
     *     for (const blob of response.segment.blobItems) {
     *       console.log(`Blob ${i++}: ${blob.name}`);
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // Passing marker as an argument (similar to the previous example)
     *   let i = 1;
     *   let iterator = containerClient.listBlobsFlat().byPage({ maxPageSize: 2 });
     *   let response = (await iterator.next()).value;
     *   // Prints 2 blob names
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *    }
     *   // Gets next marker
     *   let marker = response.continuationToken;
     *    // Passing next marker as continuationToken
     *   iterator = containerClient.listBlobsFlat().byPage({ continuationToken: marker, maxPageSize: 10 });
     *   response = (await iterator.next()).value;
     *   // Prints 10 blob names
     *   for (const blob of response.segment.blobItems) {
     *     console.log(`Blob ${i++}: ${blob.name}`);
     *   }
     * ```
     *
     * @param {ContainerListBlobsOptions} [options={}] Options to list blobs.
     * @returns {PagedAsyncIterableIterator<BlobItem, ContainerListBlobFlatSegmentResponse>} An asyncIterableIterator that supports paging.
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listBlobsFlat = function (options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var include = [];
        if (options.includeCopy) {
            include.push("copy");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeUncommitedBlobs) {
            include.push("uncommittedblobs");
        }
        var updatedOptions = __assign(__assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over blobs
        var iter = this.listItems(updatedOptions);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return iter.next();
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listSegments(settings.continuationToken, __assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
            },
            _a;
    };
    /**
     * Returns an AsyncIterableIterator for ContainerListBlobHierarchySegmentResponse
     *
     * @private
     * @param {string} delimiter The charactor or string used to define the virtual hierarchy
     * @param {string} [marker] A string value that identifies the portion of
     *                          the list of blobs to be returned with the next listing operation. The
     *                          operation returns the ContinuationToken value within the response body if the
     *                          listing operation did not return all blobs remaining to be listed
     *                          with the current page. The ContinuationToken value can be used as the value for
     *                          the marker parameter in a subsequent call to request the next page of list
     *                          items. The marker value is opaque to the client.
     * @param {ContainerListBlobsSegmentOptions} [options] Options to list blobs operation.
     * @returns {AsyncIterableIterator<ContainerListBlobHierarchySegmentResponse>}
     * @memberof ContainerClient
     */ ContainerClient.prototype.listHierarchySegments = function (delimiter, marker, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listHierarchySegments_1() {
            var listBlobsHierarchySegmentResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!!marker || marker === undefined)) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1: return [4 /*yield*/, __await(this.listBlobHierarchySegment(delimiter, marker, options))];
                    case 2:
                        listBlobsHierarchySegmentResponse = _a.sent();
                        marker = listBlobsHierarchySegmentResponse.continuationToken;
                        return [4 /*yield*/, __await(listBlobsHierarchySegmentResponse)];
                    case 3: return [4 /*yield*/, __await.apply(void 0, [_a.sent()])];
                    case 4: return [4 /*yield*/, _a.sent()];
                    case 5:
                        _a.sent();
                        _a.label = 6;
                    case 6:
                        if (marker) return [3 /*break*/, 1];
                        _a.label = 7;
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an AsyncIterableIterator for {@link BlobPrefix} and {@link BlobItem} objects.
     *
     * @private
     * @param {string} delimiter The charactor or string used to define the virtual hierarchy
     * @param {ContainerListBlobsSegmentOptions} [options] Options to list blobs operation.
     * @returns {AsyncIterableIterator<{ kind: "prefix" } & BlobPrefix | { kind: "blob" } & BlobItem>}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listItemsByHierarchy = function (delimiter, options) {
        if (options === void 0) { options = {}; }
        return __asyncGenerator(this, arguments, function listItemsByHierarchy_1() {
            var marker, _a, _b, listBlobsHierarchySegmentResponse, segment, _i, _c, prefix, _d, _e, blob, e_6_1;
            var e_6, _f;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _g.trys.push([0, 14, 15, 20]);
                        _a = __asyncValues(this.listHierarchySegments(delimiter, marker, options));
                        _g.label = 1;
                    case 1: return [4 /*yield*/, __await(_a.next())];
                    case 2:
                        if (!(_b = _g.sent(), !_b.done)) return [3 /*break*/, 13];
                        listBlobsHierarchySegmentResponse = _b.value;
                        segment = listBlobsHierarchySegmentResponse.segment;
                        if (!segment.blobPrefixes) return [3 /*break*/, 7];
                        _i = 0, _c = segment.blobPrefixes;
                        _g.label = 3;
                    case 3:
                        if (!(_i < _c.length)) return [3 /*break*/, 7];
                        prefix = _c[_i];
                        return [4 /*yield*/, __await(__assign({ kind: "prefix" }, prefix))];
                    case 4: return [4 /*yield*/, _g.sent()];
                    case 5:
                        _g.sent();
                        _g.label = 6;
                    case 6:
                        _i++;
                        return [3 /*break*/, 3];
                    case 7:
                        _d = 0, _e = segment.blobItems;
                        _g.label = 8;
                    case 8:
                        if (!(_d < _e.length)) return [3 /*break*/, 12];
                        blob = _e[_d];
                        return [4 /*yield*/, __await(__assign({ kind: "blob" }, blob))];
                    case 9: return [4 /*yield*/, _g.sent()];
                    case 10:
                        _g.sent();
                        _g.label = 11;
                    case 11:
                        _d++;
                        return [3 /*break*/, 8];
                    case 12: return [3 /*break*/, 1];
                    case 13: return [3 /*break*/, 20];
                    case 14:
                        e_6_1 = _g.sent();
                        e_6 = { error: e_6_1 };
                        return [3 /*break*/, 20];
                    case 15:
                        _g.trys.push([15, , 18, 19]);
                        if (!(_b && !_b.done && (_f = _a.return))) return [3 /*break*/, 17];
                        return [4 /*yield*/, __await(_f.call(_a))];
                    case 16:
                        _g.sent();
                        _g.label = 17;
                    case 17: return [3 /*break*/, 19];
                    case 18:
                        if (e_6) throw e_6.error;
                        return [7 /*endfinally*/];
                    case 19: return [7 /*endfinally*/];
                    case 20: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns an async iterable iterator to list all the blobs by hierarchy.
     * under the specified account.
     *
     * .byPage() returns an async iterable iterator to list the blobs by hierarchy in pages.
     *
     * @example
     * ```js
     *   for await (const item of containerClient.listBlobsByHierarchy("/")) {
     *     if (item.kind === "prefix") {
     *       console.log(`\tBlobPrefix: ${item.name}`);
     *     } else {
     *       console.log(`\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     * // Generator syntax .next() and passing a prefix
     * let iter = await containerClient.listBlobsByHierarchy("/", { prefix: "prefix1/" });
     * let entity = await iter.next();
     * while (!entity.done) {
     *   let item = entity.value;
     *   if (item.kind === "prefix") {
     *     console.log(`\tBlobPrefix: ${item.name}`);
     *   } else {
     *     console.log(`\tBlobItem: name - ${item.name}, last modified - ${item.properties.lastModified}`);
     *   }
     *   entity = await iter.next();
     * }
     * ```js
     *
     * @example
     * ```js
     *   // byPage()
     *   console.log("Listing blobs by hierarchy by page");
     *   for await (const response of containerClient.listBlobsByHierarchy("/").byPage()) {
     *     const segment = response.segment;
     *     if (segment.blobPrefixes) {
     *       for (const prefix of segment.blobPrefixes) {
     *         console.log(`\tBlobPrefix: ${prefix.name}`);
     *       }
     *     }
     *     for (const blob of response.segment.blobItems) {
     *       console.log(`\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);
     *     }
     *   }
     * ```
     *
     * @example
     * ```js
     *   // 4. byPage() and passing a prefix and max page size
     *   console.log("Listing blobs by hierarchy by page, specifying a prefix and a max page size");
     *   let i = 1;
     *   for await (const response of containerClient.listBlobsByHierarchy("/", { prefix: "prefix2/sub1/"}).byPage({ maxPageSize: 2 })) {
     *     console.log(`Page ${i++}`);
     *     const segment = response.segment;
     *     if (segment.blobPrefixes) {
     *       for (const prefix of segment.blobPrefixes) {
     *         console.log(`\tBlobPrefix: ${prefix.name}`);
     *       }
     *     }
     *     for (const blob of response.segment.blobItems) {
     *       console.log(`\tBlobItem: name - ${blob.name}, last modified - ${blob.properties.lastModified}`);
     *     }
     *   }
     * ```
     *
     * @param {string} delimiter The charactor or string used to define the virtual hierarchy
     * @param {ContainerListBlobsOptions} [options={}] Options to list blobs operation.
     * @returns {(PagedAsyncIterableIterator<
     *   { kind: "prefix" } & BlobPrefix | { kind: "blob" } & BlobItem,
     *     ContainerListBlobHierarchySegmentResponse
     *   >)}
     * @memberof ContainerClient
     */
    ContainerClient.prototype.listBlobsByHierarchy = function (delimiter, options) {
        var _a;
        var _this = this;
        if (options === void 0) { options = {}; }
        var include = [];
        if (options.includeCopy) {
            include.push("copy");
        }
        if (options.includeDeleted) {
            include.push("deleted");
        }
        if (options.includeMetadata) {
            include.push("metadata");
        }
        if (options.includeSnapshots) {
            include.push("snapshots");
        }
        if (options.includeUncommitedBlobs) {
            include.push("uncommittedblobs");
        }
        var updatedOptions = __assign(__assign({}, options), (include.length > 0 ? { include: include } : {}));
        // AsyncIterableIterator to iterate over blob prefixes and blobs
        var iter = this.listItemsByHierarchy(delimiter, updatedOptions);
        return _a = {
                /**
                 * @member {Promise} [next] The next method, part of the iteration protocol
                 */
                next: function () {
                    return __awaiter(this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, iter.next()];
                        });
                    });
                }
            },
            /**
             * @member {Symbol} [asyncIterator] The connection to the async iterator, part of the iteration protocol
             */
            _a[Symbol.asyncIterator] = function () {
                return this;
            },
            /**
             * @member {Function} [byPage] Return an AsyncIterableIterator that works a page at a time
             */
            _a.byPage = function (settings) {
                if (settings === void 0) { settings = {}; }
                return _this.listHierarchySegments(delimiter, settings.continuationToken, __assign({ maxPageSize: settings.maxPageSize }, updatedOptions));
            },
            _a;
    };
    ContainerClient.prototype.getContainerNameFromUrl = function () {
        var containerName;
        try {
            //  URL may look like the following
            // "https://myaccount.blob.core.windows.net/mycontainer?sasString";
            // "https://myaccount.blob.core.windows.net/mycontainer";
            // or an emulator URL that starts with the endpoint `http://127.0.0.1:10000/devstoreaccount1`
            var urlWithoutSAS = this.url.split("?")[0]; // removing the sas part of url if present
            urlWithoutSAS = urlWithoutSAS.endsWith("/") ? urlWithoutSAS.slice(0, -1) : urlWithoutSAS; // Slicing off '/' at the end if exists
            // http://127.0.0.1:10000/devstoreaccount1
            var emulatorBlobEndpoint = getValueInConnString(DevelopmentConnectionString, "BlobEndpoint");
            if (this.url.startsWith(emulatorBlobEndpoint)) {
                // Emulator URL starts with `http://127.0.0.1:10000/devstoreaccount1`
                var partsOfUrl = urlWithoutSAS.match(emulatorBlobEndpoint + "/([^/]*)");
                containerName = partsOfUrl[1];
            }
            else {
                var partsOfUrl = urlWithoutSAS.match("([^/]*)://([^/]*)/([^/]*)");
                // decode the encoded containerName - to get all the special characters that might be present in it
                containerName = partsOfUrl[3];
            }
            containerName = decodeURIComponent(containerName);
            if (!containerName) {
                throw new Error("Provided containerName is invalid.");
            }
            return containerName;
        }
        catch (error) {
            throw new Error("Unable to extract containerName with provided information.");
        }
    };
    return ContainerClient;
}(StorageClient));
export { ContainerClient };
//# sourceMappingURL=ContainerClient.js.map