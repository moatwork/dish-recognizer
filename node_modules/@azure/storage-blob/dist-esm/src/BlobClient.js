// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { isNode, isTokenCredential, getDefaultProxySettings } from "@azure/core-http";
import { CanonicalCode } from "@azure/core-tracing";
import { BlobDownloadResponse } from "./BlobDownloadResponse";
import { Blob as StorageBlob } from "./generated/src/operations";
import { rangeToString } from "./Range";
import { ensureCpkIfSpecified, toAccessTier } from "./models";
import { newPipeline, Pipeline } from "./Pipeline";
import { DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS, URLConstants, DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES, DevelopmentConnectionString, DEFAULT_BLOCK_BUFFER_SIZE_BYTES } from "./utils/constants";
import { setURLParameter, extractConnectionStringParts, appendToURLPath, getValueInConnString } from "./utils/utils.common";
import { readStreamToLocalFile } from "./utils/utils.node";
import { StorageSharedKeyCredential } from "./credentials/StorageSharedKeyCredential";
import { AnonymousCredential } from "./credentials/AnonymousCredential";
import { Batch } from "./utils/Batch";
import { streamToBuffer } from "./utils/utils.node";
import { BlobLeaseClient } from "./BlobLeaseClient";
import { createSpan } from "./utils/tracing";
import { AppendBlob } from "./generated/src/operations";
import { StorageClient } from "./StorageClient";
import * as fs from "fs";
import { generateUuid } from "@azure/core-http";
import { BlockBlob } from "./generated/src/operations";
import { generateBlockID } from "./utils/utils.common";
import { fsStat } from "./utils/utils.node";
import { BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES, BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES, BLOCK_BLOB_MAX_BLOCKS } from "./utils/constants";
import { BufferScheduler } from "./utils/BufferScheduler";
import { PageBlob } from "./generated/src/operations";
import { rangeResponseFromModel } from "./PageBlobRangeResponse";
import { BlobBeginCopyFromUrlPoller } from "./pollers/BlobStartCopyFromUrlPoller";
/**
 * A BlobClient represents a URL to an Azure Storage blob; the blob may be a block blob,
 * append blob, or page blob.
 *
 * @export
 * @class BlobClient
 */
var BlobClient = /** @class */ (function (_super) {
    __extends(BlobClient, _super);
    function BlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        var _a;
        var _this = this;
        options = options || {};
        var pipeline;
        var url;
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            options = blobNameOrOptions;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string" &&
            blobNameOrOptions &&
            typeof blobNameOrOptions === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            var containerName = credentialOrPipelineOrContainerName;
            var blobName = blobNameOrOptions;
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url =
                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +
                        "?" +
                        extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        _this = _super.call(this, url, pipeline) || this;
        (_a = _this.getBlobAndContainerNamesFromUrl(), _this._name = _a.blobName, _this._containerName = _a.containerName);
        _this.blobContext = new StorageBlob(_this.storageClientContext);
        return _this;
    }
    Object.defineProperty(BlobClient.prototype, "name", {
        /**
         * The name of the blob.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlobClient.prototype, "containerName", {
        /**
         * The name of the storage container the blob is associated with.
         */
        get: function () {
            return this._containerName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new BlobClient object identical to the source but with the specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {BlobClient} A new BlobClient object identical to the source but with the specified snapshot timestamp
     * @memberof BlobClient
     */
    BlobClient.prototype.withSnapshot = function (snapshot) {
        return new BlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a AppendBlobClient object.
     *
     * @returns {AppendBlobClient}
     * @memberof BlobClient
     */
    BlobClient.prototype.getAppendBlobClient = function () {
        return new AppendBlobClient(this.url, this.pipeline);
    };
    /**
     * Creates a BlockBlobClient object.
     *
     * @returns {BlockBlobClient}
     * @memberof BlobClient
     */
    BlobClient.prototype.getBlockBlobClient = function () {
        return new BlockBlobClient(this.url, this.pipeline);
    };
    /**
     * Creates a PageBlobClient object.
     *
     * @returns {PageBlobClient}
     * @memberof BlobClient
     */
    BlobClient.prototype.getPageBlobClient = function () {
        return new PageBlobClient(this.url, this.pipeline);
    };
    /**
     * Reads or downloads a blob from the system, including its metadata and properties.
     * You can also call Get Blob to read a snapshot.
     *
     * * In Node.js, data returns in a Readable stream readableStreamBody
     * * In browsers, data returns in a promise blobBody
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob
     *
     * @param {number} [offset] From which position of the blob to download, >= 0
     * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined
     * @param {BlobDownloadOptions} [options] Optional options to Blob Download operation.
     * @returns {Promise<BlobDownloadResponseModel>}
     * @memberof BlobClient
     *
     * @example
     * ```js
     * // Download and convert a blob to a string (Node.js only)
     * const downloadBlockBlobResponse = await blobClient.download();
     * const downloaded = await streamToString(downloadBlockBlobResponse.readableStreamBody);
     * console.log("Downloaded blob content:", downloaded);
     *
     * async function streamToString(readableStream) {
     *   return new Promise((resolve, reject) => {
     *     const chunks = [];
     *     readableStream.on("data", (data) => {
     *       chunks.push(data.toString());
     *     });
     *     readableStream.on("end", () => {
     *       resolve(chunks.join(""));
     *     });
     *     readableStream.on("error", reject);
     *   });
     * }
     * ```
     *
     * @example
     * ```js
     * // Download and convert a blob to a string (Browser only)
     * const downloadBlockBlobResponse = await blobClient.download();
     * const downloaded = await blobToString(await downloadBlockBlobResponse.blobBody);
     * console.log(
     *   "Downloaded blob content",
     *   downloaded
     * );
     *
     * async function blobToString(blob: Blob): Promise<string> {
     *   const fileReader = new FileReader();
     *   return new Promise<string>((resolve, reject) => {
     *     fileReader.onloadend = (ev: any) => {
     *       resolve(ev.target!.result);
     *     };
     *     fileReader.onerror = reject;
     *     fileReader.readAsText(blob);
     *   });
     * }
     * ```
     */
    BlobClient.prototype.download = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, res_1, e_1;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        options.conditions = options.conditions || {};
                        options.conditions = options.conditions || {};
                        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                        _a = createSpan("BlobClient-download", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContext.download({
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.conditions,
                                modifiedAccessConditions: options.conditions,
                                onDownloadProgress: isNode ? undefined : options.onProgress,
                                range: offset === 0 && !count ? undefined : rangeToString({ offset: offset, count: count }),
                                rangeGetContentMD5: options.rangeGetContentMD5,
                                rangeGetContentCRC64: options.rangeGetContentCrc64,
                                snapshot: options.snapshot,
                                cpkInfo: options.customerProvidedKey,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        res_1 = _b.sent();
                        // Return browser response immediately
                        if (!isNode) {
                            return [2 /*return*/, res_1];
                        }
                        // We support retrying when download stream unexpected ends in Node.js runtime
                        // Following code shouldn't be bundled into browser build, however some
                        // bundlers may try to bundle following code and "FileReadResponse.ts".
                        // In this case, "FileDownloadResponse.browser.ts" will be used as a shim of "FileDownloadResponse.ts"
                        // The config is in package.json "browser" field
                        if (options.maxRetryRequests === undefined || options.maxRetryRequests < 0) {
                            // TODO: Default value or make it a required parameter?
                            options.maxRetryRequests = DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
                        }
                        if (res_1.contentLength === undefined) {
                            throw new RangeError("File download response doesn't contain valid content length header");
                        }
                        if (!res_1.etag) {
                            throw new RangeError("File download response doesn't contain valid etag header");
                        }
                        return [2 /*return*/, new BlobDownloadResponse(res_1, function (start) { return __awaiter(_this, void 0, void 0, function () {
                                var updatedOptions;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            updatedOptions = {
                                                leaseAccessConditions: options.conditions,
                                                modifiedAccessConditions: {
                                                    ifMatch: options.conditions.ifMatch || res_1.etag,
                                                    ifModifiedSince: options.conditions.ifModifiedSince,
                                                    ifNoneMatch: options.conditions.ifNoneMatch,
                                                    ifUnmodifiedSince: options.conditions.ifUnmodifiedSince
                                                },
                                                range: rangeToString({
                                                    count: offset + res_1.contentLength - start,
                                                    offset: start
                                                }),
                                                rangeGetContentMD5: options.rangeGetContentMD5,
                                                rangeGetContentCRC64: options.rangeGetContentCrc64,
                                                snapshot: options.snapshot,
                                                cpkInfo: options.customerProvidedKey
                                            };
                                            return [4 /*yield*/, this.blobContext.download(__assign({ abortSignal: options.abortSignal }, updatedOptions))];
                                        case 1: 
                                        // Debug purpose only
                                        // console.log(
                                        //   `Read from internal stream, range: ${
                                        //     updatedOptions.range
                                        //   }, options: ${JSON.stringify(updatedOptions)}`
                                        // );
                                        return [2 /*return*/, (_a.sent()).readableStreamBody];
                                    }
                                });
                            }); }, offset, res_1.contentLength, {
                                abortSignal: options.abortSignal,
                                maxRetryRequests: options.maxRetryRequests,
                                onProgress: options.onProgress
                            })];
                    case 3:
                        e_1 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_1.message
                        });
                        throw e_1;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns true if the Azrue blob resource represented by this client exists; false otherwise.
     *
     * NOTE: use this function with care since an existing blob might be deleted by other clients or
     * applications. Vice versa new blobs might be added by other clients or applications after this
     * function completes.
     *
     * @param {BlobExistsOptions} [options] options to Exists operation.
     * @returns {Promise<boolean>}
     * @memberof BlobClient
     */
    BlobClient.prototype.exists = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_2;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("BlobClient-exists", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                        return [4 /*yield*/, this.getProperties({
                                abortSignal: options.abortSignal,
                                customerProvidedKey: options.customerProvidedKey,
                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                            })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, true];
                    case 3:
                        e_2 = _b.sent();
                        if (e_2.statusCode === 404) {
                            span.setStatus({
                                code: CanonicalCode.NOT_FOUND,
                                message: "Expected exception when checking blob existence"
                            });
                            return [2 /*return*/, false];
                        }
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_2.message
                        });
                        throw e_2;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Returns all user-defined metadata, standard HTTP properties, and system properties
     * for the blob. It does not return the content of the blob.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/get-blob-properties
     *
     * @param {BlobGetPropertiesOptions} [options] Optional options to Get Properties operation.
     * @returns {Promise<BlobGetPropertiesResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.getProperties = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-getProperties", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    options.conditions = options.conditions || {};
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blobContext.getProperties({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Marks the specified blob or snapshot for deletion. The blob is later deleted
     * during garbage collection. Note that in order to delete a blob, you must delete
     * all of its snapshots. You can delete both at the same time with the Delete
     * Blob operation.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/delete-blob
     *
     * @param {BlobDeleteOptions} [options] Optional options to Blob Delete operation.
     * @returns {Promise<BlobDeleteResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.delete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-delete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    return [2 /*return*/, this.blobContext.deleteMethod({
                            abortSignal: options.abortSignal,
                            deleteSnapshots: options.deleteSnapshots,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Restores the contents and metadata of soft deleted blob and any associated
     * soft deleted snapshots. Undelete Blob is supported only on version 2017-07-29
     * or later.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/undelete-blob
     *
     * @param {BlobUndeleteOptions} [options] Optional options to Blob Undelete operation.
     * @returns {Promise<BlobUndeleteResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.undelete = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-undelete", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.blobContext.undelete({
                            abortSignal: options.abortSignal,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets system properties on the blob.
     *
     * If no value provided, or no value provided for the specificed blob HTTP headers,
     * these blob HTTP headers without a value will be cleared.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
     *
     * @param {BlobHTTPHeaders} [blobHTTPHeaders] If no value provided, or no value provided for
     *                                                   the specificed blob HTTP headers, these blob HTTP
     *                                                   headers without a value will be cleared.
     * @param {BlobSetHTTPHeadersOptions} [options] Optional options to Blob Set HTTP Headers operation.
     * @returns {Promise<BlobSetHTTPHeadersResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.setHTTPHeaders = function (blobHTTPHeaders, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-setHTTPHeaders", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blobContext.setHTTPHeaders({
                            abortSignal: options.abortSignal,
                            blobHTTPHeaders: blobHTTPHeaders,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets user-defined metadata for the specified blob as one or more name-value pairs.
     *
     * If no option provided, or no metadata defined in the parameter, the blob
     * metadata will be removed.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-metadata
     *
     * @param {Metadata} [metadata] Replace existing metadata with this value.
     *                               If no value provided the existing metadata will be removed.
     * @param {BlobSetMetadataOptions} [options] Optional options to Set Metadata operation.
     * @returns {Promise<BlobSetMetadataResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.setMetadata = function (metadata, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-setMetadata", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blobContext.setMetadata({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            metadata: metadata,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Get a {@link BlobLeaseClient} that manages leases on the blob.
     *
     * @param {string} [proposeLeaseId] Initial proposed lease Id.
     * @returns {BlobLeaseClient} A new BlobLeaseClient object for managing leases on the blob.
     * @memberof BlobClient
     */
    BlobClient.prototype.getBlobLeaseClient = function (proposeLeaseId) {
        return new BlobLeaseClient(this, proposeLeaseId);
    };
    /**
     * Creates a read-only snapshot of a blob.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/snapshot-blob
     *
     * @param {BlobCreateSnapshotOptions} [options] Optional options to the Blob Create Snapshot operation.
     * @returns {Promise<BlobCreateSnapshotResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.createSnapshot = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-createSnapshot", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blobContext.createSnapshot({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Asynchronously copies a blob to a destination within the storage account.
     * This method returns a long running operation poller that allows you to wait
     * indefinitely until the copy is completed.
     * You can also cancel a copy before it is completed by calling `cancelOperation` on the poller.
     * Note that attempting to cancel a completed copy will result in an error being thrown.
     *
     * In version 2012-02-12 and later, the source for a Copy Blob operation can be
     * a committed blob in any Azure storage account.
     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
     * an Azure file in any Azure storage account.
     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
     * operation to copy from another storage account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob
     *
     * Example usage of automatic polling:
     * ```js
     * const copyPoller = await blobClient.beginCopyFromURL('url');
     * const result = await copyPoller.pollUntilDone();
     * ```
     *
     * Example usage of manual polling:
     * ```js
     * const copyPoller = await blobClient.beginCopyFromURL('url');
     * while (!poller.isDone()) {
     *    await poller.poll();
     * }
     * const result = copyPoller.getResult();
     * ```
     *
     * Example usage of progress updates:
     * ```js
     * const copyPoller = await blobClient.beginCopyFromURL('url', {
     *   onProgress(state) {
     *     console.log(`Progress: ${state.copyProgress}`);
     *   }
     * });
     * const result = await copyPoller.pollUntilDone();
     * ```
     *
     * Example usage of changing polling interval (default 15 seconds):
     * ```js
     * const copyPoller = await blobClient.beginCopyFromURL('url', {
     *   intervalInMs: 1000 // poll blob every 1 second for copy progress
     * });
     * const result = await copyPoller.pollUntilDone();
     * ```
     *
     * Example usage of copy cancellation:
     * ```js
     * const copyPoller = await blobClient.beginCopyFromURL('url');
     * // cancel operation after starting it.
     * try {
     *   await copyPoller.cancelOperation();
     *   // calls to get the result now throw PollerCancelledError
     *   await copyPoller.getResult();
     * } catch (err) {
     *   if (err.name === 'PollerCancelledError') {
     *     console.log('The copy was cancelled.');
     *   }
     * }
     * ```
     *
     * @param {string} copySource url to the source Azure Blob/File.
     * @param {BlobBeginCopyFromURLOptions} [options] Optional options to the Blob Start Copy From URL operation.
     */
    BlobClient.prototype.beginCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var client, poller;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        client = {
                            abortCopyFromURL: function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                return _this.abortCopyFromURL.apply(_this, args);
                            },
                            getProperties: function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                return _this.getProperties.apply(_this, args);
                            },
                            startCopyFromURL: function () {
                                var args = [];
                                for (var _i = 0; _i < arguments.length; _i++) {
                                    args[_i] = arguments[_i];
                                }
                                return _this.startCopyFromURL.apply(_this, args);
                            }
                        };
                        poller = new BlobBeginCopyFromUrlPoller({
                            blobClient: client,
                            copySource: copySource,
                            intervalInMs: options.intervalInMs,
                            onProgress: options.onProgress,
                            resumeFrom: options.resumeFrom,
                            startCopyFromURLOptions: options
                        });
                        // Trigger the startCopyFromURL call by calling poll.
                        // Any errors from this method should be surfaced to the user.
                        return [4 /*yield*/, poller.poll()];
                    case 1:
                        // Trigger the startCopyFromURL call by calling poll.
                        // Any errors from this method should be surfaced to the user.
                        _a.sent();
                        return [2 /*return*/, poller];
                }
            });
        });
    };
    /**
     * Aborts a pending asynchronous Copy Blob operation, and leaves a destination blob with zero
     * length and full metadata. Version 2012-02-12 and newer.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/abort-copy-blob
     *
     * @param {string} copyId Id of the Copy From URL operation.
     * @param {BlobAbortCopyFromURLOptions} [options] Optional options to the Blob Abort Copy From URL operation.
     * @returns {Promise<BlobAbortCopyFromURLResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.abortCopyFromURL = function (copyId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-abortCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.blobContext.abortCopyFromURL(copyId, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * The synchronous Copy From URL operation copies a blob or an internet resource to a new blob. It will not
     * return a response until the copy is complete.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob-from-url
     *
     * @param {string} copySource The source URL to copy from, Shared Access Signature(SAS) maybe needed for authentication
     * @param {BlobSyncCopyFromURLOptions} [options={}]
     * @returns {Promise<BlobCopyFromURLResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.syncCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-syncCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    return [2 /*return*/, this.blobContext.copyFromURL(copySource, {
                            abortSignal: options.abortSignal,
                            metadata: options.metadata,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            sourceModifiedAccessConditions: {
                                sourceIfMatch: options.sourceConditions.ifMatch,
                                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                            },
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets the tier on a blob. The operation is allowed on a page blob in a premium
     * storage account and on a block blob in a blob storage account (locally redundant
     * storage only). A premium page blob's tier determines the allowed size, IOPS,
     * and bandwidth of the blob. A block blob's tier determines Hot/Cool/Archive
     * storage type. This operation does not update the blob's ETag.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-tier
     *
     * @param {BlockBlobTier | PremiumPageBlobTier | string} tier The tier to be set on the blob. Valid values are Hot, Cool, or Archive.
     * @param {BlobSetTierOptions} [options] Optional options to the Blob Set Tier operation.
     * @returns {Promise<BlobsSetTierResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.setAccessTier = function (tier, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, e_3;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("BlobClient-setAccessTier", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blobContext.setTier(toAccessTier(tier), {
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.conditions,
                                rehydratePriority: options.rehydratePriority,
                                spanOptions: spanOptions
                            })];
                    case 2: return [2 /*return*/, _b.sent()];
                    case 3:
                        e_3 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_3.message
                        });
                        throw e_3;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    BlobClient.prototype.downloadToBuffer = function (param1, param2, param3, param4) {
        if (param4 === void 0) { param4 = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var buffer, offset, count, options, _a, span, spanOptions, response, transferProgress_1, batch, _loop_1, off, e_4;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        offset = 0;
                        count = 0;
                        options = param4;
                        if (param1 instanceof Buffer) {
                            buffer = param1;
                            offset = param2 || 0;
                            count = typeof param3 === "number" ? param3 : 0;
                        }
                        else {
                            offset = typeof param1 === "number" ? param1 : 0;
                            count = typeof param2 === "number" ? param2 : 0;
                            options = param3 || {};
                        }
                        _a = createSpan("BlobClient-downloadToBuffer", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        if (!options.blockSize) {
                            options.blockSize = 0;
                        }
                        if (options.blockSize < 0) {
                            throw new RangeError("blockSize option must be >= 0");
                        }
                        if (options.blockSize === 0) {
                            options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
                        }
                        if (offset < 0) {
                            throw new RangeError("offset option must be >= 0");
                        }
                        if (count && count <= 0) {
                            throw new RangeError("count option must be > 0");
                        }
                        if (!options.conditions) {
                            options.conditions = {};
                        }
                        if (!!count) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.getProperties(__assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        response = _b.sent();
                        count = response.contentLength - offset;
                        if (count < 0) {
                            throw new RangeError("offset " + offset + " shouldn't be larger than blob size " + response.contentLength);
                        }
                        _b.label = 3;
                    case 3:
                        // Allocate the buffer of size = count if the buffer is not provided
                        if (!buffer) {
                            try {
                                buffer = Buffer.alloc(count);
                            }
                            catch (error) {
                                throw new Error("Unable to allocate the buffer of size: " + count + "(in bytes). Please try passing your own buffer to the \"downloadToBuffer\" method or try using other methods like \"download\" or \"downloadToFile\".\t " + error.message);
                            }
                        }
                        if (buffer.length < count) {
                            throw new RangeError("The buffer's size should be equal to or larger than the request count of bytes: " + count);
                        }
                        transferProgress_1 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_1 = function (off) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var chunkEnd, response, stream;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            chunkEnd = offset + count;
                                            if (off + options.blockSize < chunkEnd) {
                                                chunkEnd = off + options.blockSize;
                                            }
                                            return [4 /*yield*/, this.download(off, chunkEnd - off, {
                                                    abortSignal: options.abortSignal,
                                                    conditions: options.conditions,
                                                    maxRetryRequests: options.maxRetryRequestsPerBlock,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            response = _a.sent();
                                            stream = response.readableStreamBody;
                                            return [4 /*yield*/, streamToBuffer(stream, buffer, off - offset, chunkEnd - offset)];
                                        case 2:
                                            _a.sent();
                                            // Update progress after block is downloaded, in case of block trying
                                            // Could provide finer grained progress updating inside HTTP requests,
                                            // only if convenience layer download try is enabled
                                            transferProgress_1 += chunkEnd - off;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_1 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (off = offset; off < offset + count; off = off + options.blockSize) {
                            _loop_1(off);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 4:
                        _b.sent();
                        return [2 /*return*/, buffer];
                    case 5:
                        e_4 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_4.message
                        });
                        throw e_4;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Downloads an Azure Blob to a local file.
     * Fails if the the given file path already exits.
     * Offset and count are optional, pass 0 and undefined respectively to download the entire blob.
     *
     * @param {string} filePath
     * @param {number} [offset] From which position of the block blob to download.
     * @param {number} [count] How much data to be downloaded. Will download to the end when passing undefined.
     * @param {BlobDownloadOptions} [options] Options to Blob download options.
     * @returns {Promise<BlobDownloadResponseModel>} The response data for blob download operation,
     *                                                 but with readableStreamBody set to undefined since its
     *                                                 content is already read and written into a local file
     *                                                 at the specified path.
     * @memberof BlobClient
     */
    BlobClient.prototype.downloadToFile = function (filePath, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, response, e_5;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("BlobClient-downloadToFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, 6, 7]);
                        return [4 /*yield*/, this.download(offset, count, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 2:
                        response = _b.sent();
                        if (!response.readableStreamBody) return [3 /*break*/, 4];
                        return [4 /*yield*/, readStreamToLocalFile(response.readableStreamBody, filePath)];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4:
                        // The stream is no longer accessible so setting it to undefined.
                        response.blobDownloadStream = undefined;
                        return [2 /*return*/, response];
                    case 5:
                        e_5 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_5.message
                        });
                        throw e_5;
                    case 6:
                        span.end();
                        return [7 /*endfinally*/];
                    case 7: return [2 /*return*/];
                }
            });
        });
    };
    BlobClient.prototype.getBlobAndContainerNamesFromUrl = function () {
        var containerName;
        var blobName;
        try {
            //  URL may look like the following
            // "https://myaccount.blob.core.windows.net/mycontainer/blob?sasString";
            // "https://myaccount.blob.core.windows.net/mycontainer/blob";
            // "https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt?sasString";
            // "https://myaccount.blob.core.windows.net/mycontainer/blob/a.txt";
            // or an emulator URL that starts with the endpoint `http://127.0.0.1:10000/devstoreaccount1`
            var urlWithoutSAS = this.url.split("?")[0]; // removing the sas part of url if present
            urlWithoutSAS = urlWithoutSAS.endsWith("/") ? urlWithoutSAS.slice(0, -1) : urlWithoutSAS; // Slicing off '/' at the end if exists
            // http://127.0.0.1:10000/devstoreaccount1
            var emulatorBlobEndpoint = getValueInConnString(DevelopmentConnectionString, "BlobEndpoint");
            if (this.url.startsWith(emulatorBlobEndpoint)) {
                // Emulator URL starts with `http://127.0.0.1:10000/devstoreaccount1`
                var partsOfUrl = urlWithoutSAS.match(emulatorBlobEndpoint + "/([^/]*)(/(.*))?");
                containerName = partsOfUrl[1];
                blobName = partsOfUrl[3];
            }
            else {
                var partsOfUrl = urlWithoutSAS.match("([^/]*)://([^/]*)/([^/]*)(/(.*))?");
                containerName = partsOfUrl[3];
                blobName = partsOfUrl[5];
            }
            // decode the encoded blobName, containerName - to get all the special characters that might be present in them
            containerName = decodeURIComponent(containerName);
            blobName = decodeURIComponent(blobName);
            // Azure Storage Server will replace "\" with "/" in the blob names
            //   doing the same in the SDK side so that the user doesn't have to replace "\" instances in the blobName
            blobName = blobName.replace(/\\/g, "/");
            if (!blobName) {
                throw new Error("Provided blobName is invalid.");
            }
            else if (!containerName) {
                throw new Error("Provided containerName is invalid.");
            }
            else {
                return { blobName: blobName, containerName: containerName };
            }
        }
        catch (error) {
            throw new Error("Unable to extract blobName and containerName with provided information.");
        }
    };
    /**
     * Asynchronously copies a blob to a destination within the storage account.
     * In version 2012-02-12 and later, the source for a Copy Blob operation can be
     * a committed blob in any Azure storage account.
     * Beginning with version 2015-02-21, the source for a Copy Blob operation can be
     * an Azure file in any Azure storage account.
     * Only storage accounts created on or after June 7th, 2012 allow the Copy Blob
     * operation to copy from another storage account.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/copy-blob
     *
     * @param {string} copySource url to the source Azure Blob/File.
     * @param {BlobStartCopyFromURLOptions} [options] Optional options to the Blob Start Copy From URL operation.
     * @returns {Promise<BlobStartCopyFromURLResponse>}
     * @memberof BlobClient
     */
    BlobClient.prototype.startCopyFromURL = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlobClient-startCopyFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    return [2 /*return*/, this.blobContext.startCopyFromURL(copySource, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            sourceModifiedAccessConditions: {
                                sourceIfMatch: options.sourceConditions.ifMatch,
                                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                            },
                            rehydratePriority: options.rehydratePriority,
                            tier: toAccessTier(options.tier),
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return BlobClient;
}(StorageClient));
export { BlobClient };
/**
 * AppendBlobClient defines a set of operations applicable to append blobs.
 *
 * @export
 * @class AppendBlobClient
 * @extends {BlobClient}
 */
var AppendBlobClient = /** @class */ (function (_super) {
    __extends(AppendBlobClient, _super);
    function AppendBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        var _this = this;
        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.
        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);
        var pipeline;
        var url;
        options = options || {};
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)      url = urlOrConnectionString;
            url = urlOrConnectionString;
            options = blobNameOrOptions;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            // The second parameter is undefined. Use anonymous credential.
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string" &&
            blobNameOrOptions &&
            typeof blobNameOrOptions === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            var containerName = credentialOrPipelineOrContainerName;
            var blobName = blobNameOrOptions;
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url =
                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +
                        "?" +
                        extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.appendBlobContext = new AppendBlob(_this.storageClientContext);
        return _this;
    }
    /**
     * Creates a new AppendBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {AppendBlobClient} A new AppendBlobClient object identical to the source but with the specified snapshot timestamp.
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.withSnapshot = function (snapshot) {
        return new AppendBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a 0-length append blob. Call AppendBlock to append data to an append blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param {AppendBlobCreateOptions} [options] Options to the Append Block Create operation.
     * @returns {Promise<AppendBlobCreateResponse>}
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.create = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("AppendBlobClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.appendBlobContext.create(0, {
                            abortSignal: options.abortSignal,
                            blobHTTPHeaders: options.blobHTTPHeaders,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Commits a new block of data to the end of the existing append blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/append-block
     *
     * @param {HttpRequestBody} body Data to be appended.
     * @param {number} contentLength Length of the body in bytes.
     * @param {AppendBlobAppendBlockOptions} [options] Options to the Append Block operation.
     * @returns {Promise<AppendBlobAppendBlockResponse>}
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.appendBlock = function (body, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("AppendBlobClient-appendBlock", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.appendBlobContext.appendBlock(body, contentLength, {
                            abortSignal: options.abortSignal,
                            appendPositionAccessConditions: options.conditions,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            onUploadProgress: options.onProgress,
                            transactionalContentMD5: options.transactionalContentMD5,
                            transactionalContentCrc64: options.transactionalContentCrc64,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * The Append Block operation commits a new block of data to the end of an existing append blob
     * where the contents are read from a source url.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/append-block-from-url
     *
     * @param {string} sourceURL
     *                 The url to the blob that will be the source of the copy. A source blob in the same storage account can
     *                 be authenticated via Shared Key. However, if the source is a blob in another account, the source blob
     *                 must either be public or must be authenticated via a shared access signature. If the source blob is
     *                 public, no authentication is required to perform the operation.
     * @param {number} sourceOffset Offset in source to be appended
     * @param {number} count Number of bytes to be appended as a block
     * @param {AppendBlobAppendBlockFromURLOptions} [options={}]
     * @returns {Promise<AppendBlobAppendBlockFromUrlResponse>}
     * @memberof AppendBlobClient
     */
    AppendBlobClient.prototype.appendBlockFromURL = function (sourceURL, sourceOffset, count, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("AppendBlobClient-appendBlockFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.appendBlobContext.appendBlockFromUrl(sourceURL, 0, {
                            abortSignal: options.abortSignal,
                            sourceRange: rangeToString({ offset: sourceOffset, count: count }),
                            sourceContentMD5: options.sourceContentMD5,
                            sourceContentCrc64: options.sourceContentCrc64,
                            leaseAccessConditions: options.conditions,
                            appendPositionAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            sourceModifiedAccessConditions: {
                                sourceIfMatch: options.sourceConditions.ifMatch,
                                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                            },
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return AppendBlobClient;
}(BlobClient));
export { AppendBlobClient };
/**
 * BlockBlobClient defines a set of operations applicable to block blobs.
 *
 * @export
 * @class BlockBlobClient
 * @extends {BlobClient}
 */
var BlockBlobClient = /** @class */ (function (_super) {
    __extends(BlockBlobClient, _super);
    function BlockBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        var _this = this;
        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.
        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);
        var pipeline;
        var url;
        options = options || {};
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            options = blobNameOrOptions;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string" &&
            blobNameOrOptions &&
            typeof blobNameOrOptions === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            var containerName = credentialOrPipelineOrContainerName;
            var blobName = blobNameOrOptions;
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url =
                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +
                        "?" +
                        extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.blockBlobContext = new BlockBlob(_this.storageClientContext);
        return _this;
    }
    /**
     * Creates a new BlockBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a URL to the base blob.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {BlockBlobClient} A new BlockBlobClient object identical to the source but with the specified snapshot timestamp.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.withSnapshot = function (snapshot) {
        return new BlockBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a new block blob, or updates the content of an existing block blob.
     * Updating an existing block blob overwrites any existing metadata on the blob.
     * Partial updates are not supported; the content of the existing blob is
     * overwritten with the new content. To perform a partial update of a block blob's,
     * use {@link stageBlock} and {@link commitBlockList}.
     *
     * This is a non-parallel uploading method, please use {@link uploadFile},
     * {@link uploadStream} or {@link uploadBrowserData} for better performance
     * with concurrency uploading.
     *
     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param {HttpRequestBody} body Blob, string, ArrayBuffer, ArrayBufferView or a function
     *                               which returns a new Readable stream whose offset is from data source beginning.
     * @param {number} contentLength Length of body in bytes. Use Buffer.byteLength() to calculate body length for a
     *                               string including non non-Base64/Hex-encoded characters.
     * @param {BlockBlobUploadOptions} [options] Options to the Block Blob Upload operation.
     * @returns {Promise<BlockBlobUploadResponse>} Response data for the Block Blob Upload operation.
     * @memberof BlockBlobClient
     *
     * @example
     * ```js
     * const content = "Hello world!";
     * const uploadBlobResponse = await blockBlobClient.upload(content, content.length);
     * ```
     */
    BlockBlobClient.prototype.upload = function (body, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("BlockBlobClient-upload", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blockBlobContext.upload(body, contentLength, {
                            abortSignal: options.abortSignal,
                            blobHTTPHeaders: options.blobHTTPHeaders,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            onUploadProgress: options.onProgress,
                            cpkInfo: options.customerProvidedKey,
                            tier: toAccessTier(options.tier),
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Uploads the specified block to the block blob's "staging area" to be later
     * committed by a call to commitBlockList.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-block
     *
     * @param {string} blockId A 64-byte value that is base64-encoded
     * @param {HttpRequestBody} body Data to upload to the staging area.
     * @param {number} contentLength Number of bytes to upload.
     * @param {BlockBlobStageBlockOptions} [options] Options to the Block Blob Stage Block operation.
     * @returns {Promise<BlockBlobStageBlockResponse>} Response data for the Block Blob Stage Block operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.stageBlock = function (blockId, body, contentLength, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlockBlobClient-stageBlock", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blockBlobContext.stageBlock(blockId, contentLength, body, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            onUploadProgress: options.onProgress,
                            transactionalContentMD5: options.transactionalContentMD5,
                            transactionalContentCrc64: options.transactionalContentCrc64,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * The Stage Block From URL operation creates a new block to be committed as part
     * of a blob where the contents are read from a URL.
     * This API is available starting in version 2018-03-28.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-block-from-url
     *
     * @param {string} blockId A 64-byte value that is base64-encoded
     * @param {string} sourceURL Specifies the URL of the blob. The value
     *                           may be a URL of up to 2 KB in length that specifies a blob.
     *                           The value should be URL-encoded as it would appear
     *                           in a request URI. The source blob must either be public
     *                           or must be authenticated via a shared access signature.
     *                           If the source blob is public, no authentication is required
     *                           to perform the operation. Here are some examples of source object URLs:
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob
     *                           - https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
     * @param {number} [offset] From which position of the blob to download, >= 0
     * @param {number} [count] How much data to be downloaded, > 0. Will download to the end when undefined
     * @param {BlockBlobStageBlockFromURLOptions} [options={}] Options to the Block Blob Stage Block From URL operation.
     * @returns {Promise<BlockBlobStageBlockFromURLResponse>} Response data for the Block Blob Stage Block From URL operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.stageBlockFromURL = function (blockId, sourceURL, offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("BlockBlobClient-stageBlockFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blockBlobContext.stageBlockFromURL(blockId, 0, sourceURL, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            sourceContentMD5: options.sourceContentMD5,
                            sourceContentCrc64: options.sourceContentCrc64,
                            sourceRange: offset === 0 && !count ? undefined : rangeToString({ offset: offset, count: count }),
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Writes a blob by specifying the list of block IDs that make up the blob.
     * In order to be written as part of a blob, a block must have been successfully written
     * to the server in a prior {@link stageBlock} operation. You can call {@link commitBlockList} to
     * update a blob by uploading only those blocks that have changed, then committing the new and existing
     * blocks together. Any blocks not specified in the block list and permanently deleted.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-block-list
     *
     * @param {string[]} blocks  Array of 64-byte value that is base64-encoded
     * @param {BlockBlobCommitBlockListOptions} [options] Options to the Block Blob Commit Block List operation.
     * @returns {Promise<BlockBlobCommitBlockListResponse>} Response data for the Block Blob Commit Block List operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.commitBlockList = function (blocks, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("BlockBlobClient-commitBlockList", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.blockBlobContext.commitBlockList({ latest: blocks }, {
                            abortSignal: options.abortSignal,
                            blobHTTPHeaders: options.blobHTTPHeaders,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            tier: toAccessTier(options.tier),
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns the list of blocks that have been uploaded as part of a block blob
     * using the specified block list filter.
     * @see https://docs.microsoft.com/rest/api/storageservices/get-block-list
     *
     * @param {BlockListType} listType Specifies whether to return the list of committed blocks,
     *                                        the list of uncommitted blocks, or both lists together.
     * @param {BlockBlobGetBlockListOptions} [options] Options to the Block Blob Get Block List operation.
     * @returns {Promise<BlockBlobGetBlockListResponse>} Response data for the Block Blob Get Block List operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.getBlockList = function (listType, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, res, e_6;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("BlockBlobClient-getBlockList", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, this.blockBlobContext.getBlockList(listType, {
                                abortSignal: options.abortSignal,
                                leaseAccessConditions: options.conditions,
                                spanOptions: spanOptions
                            })];
                    case 2:
                        res = _b.sent();
                        if (!res.committedBlocks) {
                            res.committedBlocks = [];
                        }
                        if (!res.uncommittedBlocks) {
                            res.uncommittedBlocks = [];
                        }
                        return [2 /*return*/, res];
                    case 3:
                        e_6 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_6.message
                        });
                        throw e_6;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    // High level functions
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser Blob/File/ArrayBuffer/ArrayBufferView object to block blob.
     *
     * When buffer length <= 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call
     * {@link commitBlockList} to commit the block list.
     *
     * @export
     * @param {Blob | ArrayBuffer | ArrayBufferView} browserData Blob, File, ArrayBuffer or ArrayBufferView
     * @param {BlockBlobParallelUploadOptions} [options] Options to upload browser data.
     * @returns {Promise<BlobUploadCommonResponse>} Response data for the Blob Upload operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.uploadBrowserData = function (browserData, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, browserBlob_1;
            return __generator(this, function (_b) {
                _a = createSpan("BlockBlobClient-uploadBrowserData", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    browserBlob_1 = new Blob([browserData]);
                    return [2 /*return*/, this.uploadSeekableBlob(function (offset, size) {
                            return browserBlob_1.slice(offset, offset + size);
                        }, browserBlob_1.size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * ONLY AVAILABLE IN BROWSERS.
     *
     * Uploads a browser {@link Blob} object to block blob. Requires a blobFactory as the data source,
     * which need to return a {@link Blob} object with the offset and size provided.
     *
     * When buffer length <= 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
     * to commit the block list.
     *
     * @param {(offset: number, size: number) => Blob} blobFactory
     * @param {number} size size of the data to upload.
     * @param {BlockBlobParallelUploadOptions} [options] Options to Upload to Block Blob operation.
     * @returns {Promise<BlobUploadCommonResponse>} Response data for the Blob Upload operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.uploadSeekableBlob = function (blobFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_1, blockList_1, blockIDPrefix_1, transferProgress_2, batch, _loop_2, i, e_7;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!options.blockSize) {
                            options.blockSize = 0;
                        }
                        if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
                            throw new RangeError("blockSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES);
                        }
                        if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {
                            options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
                        }
                        if (options.maxSingleShotSize < 0 ||
                            options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
                            throw new RangeError("maxSingleShotSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES);
                        }
                        if (options.blockSize === 0) {
                            if (size > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * BLOCK_BLOB_MAX_BLOCKS) {
                                throw new RangeError(size + " is too larger to upload to a block blob.");
                            }
                            if (size > options.maxSingleShotSize) {
                                options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);
                                if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
                                    options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
                                }
                            }
                        }
                        if (!options.blobHTTPHeaders) {
                            options.blobHTTPHeaders = {};
                        }
                        if (!options.conditions) {
                            options.conditions = {};
                        }
                        _a = createSpan("BlockBlobClient-UploadSeekableBlob", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (size <= options.maxSingleShotSize) {
                            return [2 /*return*/, this.upload(blobFactory(0, size), size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                        }
                        numBlocks_1 = Math.floor((size - 1) / options.blockSize) + 1;
                        if (numBlocks_1 > BLOCK_BLOB_MAX_BLOCKS) {
                            throw new RangeError("The buffer's size is too big or the BlockSize is too small;" +
                                ("the number of blocks must be <= " + BLOCK_BLOB_MAX_BLOCKS));
                        }
                        blockList_1 = [];
                        blockIDPrefix_1 = generateUuid();
                        transferProgress_2 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_2 = function (i) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var blockID, start, end, contentLength;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            blockID = generateBlockID(blockIDPrefix_1, i);
                                            start = options.blockSize * i;
                                            end = i === numBlocks_1 - 1 ? size : start + options.blockSize;
                                            contentLength = end - start;
                                            blockList_1.push(blockID);
                                            return [4 /*yield*/, this.stageBlock(blockID, blobFactory(start, contentLength), contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    conditions: options.conditions,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            // TODO: Hook with convenience layer progress event in finer level
                                            transferProgress_2 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({
                                                    loadedBytes: transferProgress_2
                                                });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_1; i++) {
                            _loop_2(i);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, this.commitBlockList(blockList_1, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_7 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_7.message
                        });
                        throw e_7;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a local file in blocks to a block blob.
     *
     * When file size <= 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call stageBlock to upload blocks, and finally call commitBlockList
     * to commit the block list.
     *
     * @param {string} filePath Full path of local file
     * @param {BlockBlobParallelUploadOptions} [options] Options to Upload to Block Blob operation.
     * @returns {(Promise<BlobUploadCommonResponse>)}  Response data for the Blob Upload operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.uploadFile = function (filePath, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, size, e_8;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = createSpan("BlockBlobClient-uploadFile", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        return [4 /*yield*/, fsStat(filePath)];
                    case 2:
                        size = (_b.sent()).size;
                        return [2 /*return*/, this.uploadResetableStream(function (offset, count) {
                                return fs.createReadStream(filePath, {
                                    autoClose: true,
                                    end: count ? offset + count - 1 : Infinity,
                                    start: offset
                                });
                            }, size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_8 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_8.message
                        });
                        throw e_8;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Uploads a Node.js Readable stream into block blob.
     *
     * PERFORMANCE IMPROVEMENT TIPS:
     * * Input stream highWaterMark is better to set a same value with bufferSize
     *    parameter, which will avoid Buffer.concat() operations.
     *
     * @param {Readable} stream Node.js Readable stream
     * @param {number} bufferSize Size of every buffer allocated, also the block size in the uploaded block blob. Default value is 8MB
     * @param {number} maxConcurrency  Max concurrency indicates the max number of buffers that can be allocated,
     *                                 positive correlation with max uploading concurrency. Default value is 5
     * @param {BlockBlobUploadStreamOptions} [options] Options to Upload Stream to Block Blob operation.
     * @returns {Promise<BlobUploadCommonResponse>} Response data for the Blob Upload operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.uploadStream = function (stream, bufferSize, maxConcurrency, options) {
        if (bufferSize === void 0) { bufferSize = DEFAULT_BLOCK_BUFFER_SIZE_BYTES; }
        if (maxConcurrency === void 0) { maxConcurrency = 5; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, blockNum_1, blockIDPrefix_2, transferProgress_3, blockList_2, scheduler, e_9;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!options.blobHTTPHeaders) {
                            options.blobHTTPHeaders = {};
                        }
                        if (!options.conditions) {
                            options.conditions = {};
                        }
                        _a = createSpan("BlockBlobClient-uploadStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        blockNum_1 = 0;
                        blockIDPrefix_2 = generateUuid();
                        transferProgress_3 = 0;
                        blockList_2 = [];
                        scheduler = new BufferScheduler(stream, bufferSize, maxConcurrency, function (buffer) { return __awaiter(_this, void 0, void 0, function () {
                            var blockID;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        blockID = generateBlockID(blockIDPrefix_2, blockNum_1);
                                        blockList_2.push(blockID);
                                        blockNum_1++;
                                        return [4 /*yield*/, this.stageBlock(blockID, buffer, buffer.length, {
                                                conditions: options.conditions,
                                                tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                            })];
                                    case 1:
                                        _a.sent();
                                        // Update progress after block is successfully uploaded to server, in case of block trying
                                        transferProgress_3 += buffer.length;
                                        if (options.onProgress) {
                                            options.onProgress({ loadedBytes: transferProgress_3 });
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }, 
                        // concurrency should set a smaller value than maxConcurrency, which is helpful to
                        // reduce the possibility when a outgoing handler waits for stream data, in
                        // this situation, outgoing handlers are blocked.
                        // Outgoing queue shouldn't be empty.
                        Math.ceil((maxConcurrency / 4) * 3));
                        return [4 /*yield*/, scheduler.do()];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, this.commitBlockList(blockList_2, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_9 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_9.message
                        });
                        throw e_9;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * ONLY AVAILABLE IN NODE.JS RUNTIME.
     *
     * Accepts a Node.js Readable stream factory, and uploads in blocks to a block blob.
     * The Readable stream factory must returns a Node.js Readable stream starting from the offset defined. The offset
     * is the offset in the block blob to be uploaded.
     *
     * When buffer length <= 256MB, this method will use 1 upload call to finish the upload.
     * Otherwise, this method will call {@link stageBlock} to upload blocks, and finally call {@link commitBlockList}
     * to commit the block list.
     *
     * @export
     * @param {(offset: number) => NodeJS.ReadableStream} streamFactory Returns a Node.js Readable stream starting
     *                                                                  from the offset defined
     * @param {number} size Size of the block blob
     * @param {BlockBlobParallelUploadOptions} [options] Options to Upload to Block Blob operation.
     * @returns {(Promise<BlobUploadCommonResponse>)}  Response data for the Blob Upload operation.
     * @memberof BlockBlobClient
     */
    BlockBlobClient.prototype.uploadResetableStream = function (streamFactory, size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions, numBlocks_2, blockList_3, blockIDPrefix_3, transferProgress_4, batch, _loop_3, i, e_10;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!options.blockSize) {
                            options.blockSize = 0;
                        }
                        if (options.blockSize < 0 || options.blockSize > BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
                            throw new RangeError("blockSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES);
                        }
                        if (options.maxSingleShotSize !== 0 && !options.maxSingleShotSize) {
                            options.maxSingleShotSize = BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
                        }
                        if (options.maxSingleShotSize < 0 ||
                            options.maxSingleShotSize > BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES) {
                            throw new RangeError("maxSingleShotSize option must be >= 0 and <= " + BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES);
                        }
                        if (options.blockSize === 0) {
                            if (size > BLOCK_BLOB_MAX_BLOCKS * BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES) {
                                throw new RangeError(size + " is too larger to upload to a block blob.");
                            }
                            if (size > options.maxSingleShotSize) {
                                options.blockSize = Math.ceil(size / BLOCK_BLOB_MAX_BLOCKS);
                                if (options.blockSize < DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES) {
                                    options.blockSize = DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
                                }
                            }
                        }
                        if (!options.blobHTTPHeaders) {
                            options.blobHTTPHeaders = {};
                        }
                        if (!options.conditions) {
                            options.conditions = {};
                        }
                        _a = createSpan("BlockBlobClient-uploadResetableStream", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, 4, 5]);
                        if (size <= options.maxSingleShotSize) {
                            return [2 /*return*/, this.upload(function () { return streamFactory(0); }, size, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                        }
                        numBlocks_2 = Math.floor((size - 1) / options.blockSize) + 1;
                        if (numBlocks_2 > BLOCK_BLOB_MAX_BLOCKS) {
                            throw new RangeError("The buffer's size is too big or the BlockSize is too small;" +
                                ("the number of blocks must be <= " + BLOCK_BLOB_MAX_BLOCKS));
                        }
                        blockList_3 = [];
                        blockIDPrefix_3 = generateUuid();
                        transferProgress_4 = 0;
                        batch = new Batch(options.concurrency);
                        _loop_3 = function (i) {
                            batch.addOperation(function () { return __awaiter(_this, void 0, void 0, function () {
                                var blockID, start, end, contentLength;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            blockID = generateBlockID(blockIDPrefix_3, i);
                                            start = options.blockSize * i;
                                            end = i === numBlocks_2 - 1 ? size : start + options.blockSize;
                                            contentLength = end - start;
                                            blockList_3.push(blockID);
                                            return [4 /*yield*/, this.stageBlock(blockID, function () { return streamFactory(start, contentLength); }, contentLength, {
                                                    abortSignal: options.abortSignal,
                                                    conditions: options.conditions,
                                                    tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions })
                                                })];
                                        case 1:
                                            _a.sent();
                                            // Update progress after block is successfully uploaded to server, in case of block trying
                                            transferProgress_4 += contentLength;
                                            if (options.onProgress) {
                                                options.onProgress({ loadedBytes: transferProgress_4 });
                                            }
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        };
                        for (i = 0; i < numBlocks_2; i++) {
                            _loop_3(i);
                        }
                        return [4 /*yield*/, batch.do()];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, this.commitBlockList(blockList_3, __assign(__assign({}, options), { tracingOptions: __assign(__assign({}, options.tracingOptions), { spanOptions: spanOptions }) }))];
                    case 3:
                        e_10 = _b.sent();
                        span.setStatus({
                            code: CanonicalCode.UNKNOWN,
                            message: e_10.message
                        });
                        throw e_10;
                    case 4:
                        span.end();
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    return BlockBlobClient;
}(BlobClient));
export { BlockBlobClient };
/**
 * PageBlobClient defines a set of operations applicable to page blobs.
 *
 * @export
 * @class PageBlobClient
 * @extends {BlobClient}
 */
var PageBlobClient = /** @class */ (function (_super) {
    __extends(PageBlobClient, _super);
    function PageBlobClient(urlOrConnectionString, credentialOrPipelineOrContainerName, blobNameOrOptions, options) {
        var _this = this;
        // In TypeScript we cannot simply pass all parameters to super() like below so have to duplicate the code instead.
        //   super(s, credentialOrPipelineOrContainerNameOrOptions, blobNameOrOptions, options);
        var pipeline;
        var url;
        options = options || {};
        if (credentialOrPipelineOrContainerName instanceof Pipeline) {
            // (url: string, pipeline: Pipeline)
            url = urlOrConnectionString;
            pipeline = credentialOrPipelineOrContainerName;
        }
        else if ((isNode && credentialOrPipelineOrContainerName instanceof StorageSharedKeyCredential) ||
            credentialOrPipelineOrContainerName instanceof AnonymousCredential ||
            isTokenCredential(credentialOrPipelineOrContainerName)) {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            url = urlOrConnectionString;
            options = blobNameOrOptions;
            pipeline = newPipeline(credentialOrPipelineOrContainerName, options);
        }
        else if (!credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName !== "string") {
            // (url: string, credential?: StorageSharedKeyCredential | AnonymousCredential | TokenCredential, options?: StoragePipelineOptions)
            // The second parameter is undefined. Use anonymous credential.
            url = urlOrConnectionString;
            pipeline = newPipeline(new AnonymousCredential(), options);
        }
        else if (credentialOrPipelineOrContainerName &&
            typeof credentialOrPipelineOrContainerName === "string" &&
            blobNameOrOptions &&
            typeof blobNameOrOptions === "string") {
            // (connectionString: string, containerName: string, blobName: string, options?: StoragePipelineOptions)
            var containerName = credentialOrPipelineOrContainerName;
            var blobName = blobNameOrOptions;
            var extractedCreds = extractConnectionStringParts(urlOrConnectionString);
            if (extractedCreds.kind === "AccountConnString") {
                if (isNode) {
                    var sharedKeyCredential = new StorageSharedKeyCredential(extractedCreds.accountName, extractedCreds.accountKey);
                    url = appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName));
                    options.proxyOptions = getDefaultProxySettings(extractedCreds.proxyUri);
                    pipeline = newPipeline(sharedKeyCredential, options);
                }
                else {
                    throw new Error("Account connection string is only supported in Node.js environment");
                }
            }
            else if (extractedCreds.kind === "SASConnString") {
                url =
                    appendToURLPath(appendToURLPath(extractedCreds.url, encodeURIComponent(containerName)), encodeURIComponent(blobName)) +
                        "?" +
                        extractedCreds.accountSas;
                pipeline = newPipeline(new AnonymousCredential(), options);
            }
            else {
                throw new Error("Connection string must be either an Account connection string or a SAS connection string");
            }
        }
        else {
            throw new Error("Expecting non-empty strings for containerName and blobName parameters");
        }
        _this = _super.call(this, url, pipeline) || this;
        _this.pageBlobContext = new PageBlob(_this.storageClientContext);
        return _this;
    }
    /**
     * Creates a new PageBlobClient object identical to the source but with the
     * specified snapshot timestamp.
     * Provide "" will remove the snapshot and return a Client to the base blob.
     *
     * @param {string} snapshot The snapshot timestamp.
     * @returns {PageBlobClient} A new PageBlobClient object identical to the source but with the specified snapshot timestamp.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.withSnapshot = function (snapshot) {
        return new PageBlobClient(setURLParameter(this.url, URLConstants.Parameters.SNAPSHOT, snapshot.length === 0 ? undefined : snapshot), this.pipeline);
    };
    /**
     * Creates a page blob of the specified length. Call uploadPages to upload data
     * data to a page blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-blob
     *
     * @param {number} size size of the page blob.
     * @param {PageBlobCreateOptions} [options] Options to the Page Blob Create operation.
     * @returns {Promise<PageBlobCreateResponse>} Response data for the Page Blob Create operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.create = function (size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-create", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.pageBlobContext.create(0, size, {
                            abortSignal: options.abortSignal,
                            blobHTTPHeaders: options.blobHTTPHeaders,
                            blobSequenceNumber: options.blobSequenceNumber,
                            leaseAccessConditions: options.conditions,
                            metadata: options.metadata,
                            modifiedAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            tier: toAccessTier(options.tier),
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Writes 1 or more pages to the page blob. The start and end offsets must be a multiple of 512.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-page
     *
     * @param {HttpRequestBody} body Data to upload
     * @param {number} offset Offset of destination page blob
     * @param {number} count Content length of the body, also number of bytes to be uploaded
     * @param {PageBlobUploadPagesOptions} [options] Options to the Page Blob Upload Pages operation.
     * @returns {Promise<PageBlobsUploadPagesResponse>} Response data for the Page Blob Upload Pages operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.uploadPages = function (body, offset, count, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-uploadPages", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.pageBlobContext.uploadPages(body, count, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            onUploadProgress: options.onProgress,
                            range: rangeToString({ offset: offset, count: count }),
                            sequenceNumberAccessConditions: options.conditions,
                            transactionalContentMD5: options.transactionalContentMD5,
                            transactionalContentCrc64: options.transactionalContentCrc64,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * The Upload Pages operation writes a range of pages to a page blob where the
     * contents are read from a URL.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/put-page-from-url
     *
     * @param {string} sourceURL Specify a URL to the copy source, Shared Access Signature(SAS) maybe needed for authentication
     * @param {number} sourceOffset The source offset to copy from. Pass 0 to copy from the beginning of source page blob
     * @param {number} destOffset Offset of destination page blob
     * @param {number} count Number of bytes to be uploaded from source page blob
     * @param {PageBlobUploadPagesFromURLOptions} [options={}]
     * @returns {Promise<PageBlobUploadPagesFromURLResponse>}
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.uploadPagesFromURL = function (sourceURL, sourceOffset, destOffset, count, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                options.sourceConditions = options.sourceConditions || {};
                _a = createSpan("PageBlobClient-uploadPagesFromURL", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    ensureCpkIfSpecified(options.customerProvidedKey, this.isHttps);
                    return [2 /*return*/, this.pageBlobContext.uploadPagesFromURL(sourceURL, rangeToString({ offset: sourceOffset, count: count }), 0, rangeToString({ offset: destOffset, count: count }), {
                            abortSignal: options.abortSignal,
                            sourceContentMD5: options.sourceContentMD5,
                            sourceContentCrc64: options.sourceContentCrc64,
                            leaseAccessConditions: options.conditions,
                            sequenceNumberAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            sourceModifiedAccessConditions: {
                                sourceIfMatch: options.sourceConditions.ifMatch,
                                sourceIfModifiedSince: options.sourceConditions.ifModifiedSince,
                                sourceIfNoneMatch: options.sourceConditions.ifNoneMatch,
                                sourceIfUnmodifiedSince: options.sourceConditions.ifUnmodifiedSince
                            },
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Frees the specified pages from the page blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/put-page
     *
     * @param {number} [offset] Starting byte position of the pages to clear.
     * @param {number} [count] Number of bytes to clear.
     * @param {PageBlobClearPagesOptions} [options] Options to the Page Blob Clear Pages operation.
     * @returns {Promise<PageBlobClearPagesResponse>} Response data for the Page Blob Clear Pages operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.clearPages = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-clearPages", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext.clearPages(0, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            range: rangeToString({ offset: offset, count: count }),
                            sequenceNumberAccessConditions: options.conditions,
                            cpkInfo: options.customerProvidedKey,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Returns the list of valid page ranges for a page blob or snapshot of a page blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param {number} [offset] Starting byte position of the page ranges.
     * @param {number} [count] Number of bytes to get.
     * @param {PageBlobGetPageRangesOptions} [options] Options to the Page Blob Get Ranges operation.
     * @returns {Promise<PageBlobGetPageRangesResponse>} Response data for the Page Blob Get Ranges operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.getPageRanges = function (offset, count, options) {
        if (offset === void 0) { offset = 0; }
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-getPageRanges", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext
                            .getPageRanges({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            range: rangeToString({ offset: offset, count: count }),
                            spanOptions: spanOptions
                        })
                            .then(rangeResponseFromModel)];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Gets the collection of page ranges that differ between a specified snapshot and this page blob.
     * @see https://docs.microsoft.com/rest/api/storageservices/get-page-ranges
     *
     * @param {number} offset Starting byte position of the page blob
     * @param {number} count Number of bytes to get ranges diff.
     * @param {string} prevSnapshot Timestamp of snapshot to retrive the difference.
     * @param {PageBlobGetPageRangesDiffOptions} [options] Options to the Page Blob Get Page Ranges Diff operation.
     * @returns {Promise<PageBlobGetPageRangesDiffResponse>} Response data for the Page Blob Get Page Range Diff operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.getPageRangesDiff = function (offset, count, prevSnapshot, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-getPageRangesDiff", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext
                            .getPageRangesDiff({
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            prevsnapshot: prevSnapshot,
                            range: rangeToString({ offset: offset, count: count }),
                            spanOptions: spanOptions
                        })
                            .then(rangeResponseFromModel)];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Resizes the page blob to the specified size (which must be a multiple of 512).
     * @see https://docs.microsoft.com/rest/api/storageservices/set-blob-properties
     *
     * @param {number} size Target size
     * @param {PageBlobResizeOptions} [options] Options to the Page Blob Resize operation.
     * @returns {Promise<PageBlobResizeResponse>} Response data for the Page Blob Resize operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.resize = function (size, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-resize", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext.resize(size, {
                            abortSignal: options.abortSignal,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Sets a page blob's sequence number.
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/set-blob-properties
     *
     * @param {SequenceNumberActionType} sequenceNumberAction Indicates how the service should modify the blob's sequence number.
     * @param {number} [sequenceNumber] Required if sequenceNumberAction is max or update
     * @param {PageBlobUpdateSequenceNumberOptions} [options] Options to the Page Blob Update Sequence Number operation.
     * @returns {Promise<PageBlobUpdateSequenceNumberResponse>} Response data for the Page Blob Update Sequence Number operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.updateSequenceNumber = function (sequenceNumberAction, sequenceNumber, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                options.conditions = options.conditions || {};
                _a = createSpan("PageBlobClient-updateSequenceNumber", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext.updateSequenceNumber(sequenceNumberAction, {
                            abortSignal: options.abortSignal,
                            blobSequenceNumber: sequenceNumber,
                            leaseAccessConditions: options.conditions,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    /**
     * Begins an operation to start an incremental copy from one page blob's snapshot to this page blob.
     * The snapshot is copied such that only the differential changes between the previously
     * copied snapshot are transferred to the destination.
     * The copied snapshots are complete copies of the original snapshot and can be read or copied from as usual.
     * @see https://docs.microsoft.com/rest/api/storageservices/incremental-copy-blob
     * @see https://docs.microsoft.com/en-us/azure/virtual-machines/windows/incremental-snapshots
     *
     * @param {string} copySource Specifies the name of the source page blob snapshot. For example,
     *                            https://myaccount.blob.core.windows.net/mycontainer/myblob?snapshot=<DateTime>
     * @param {PageBlobStartCopyIncrementalOptions} [options] Options to the Page Blob Copy Incremental operation.
     * @returns {Promise<PageBlobCopyIncrementalResponse>} Response data for the Page Blob Copy Incremental operation.
     * @memberof PageBlobClient
     */
    PageBlobClient.prototype.startCopyIncremental = function (copySource, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, span, spanOptions;
            return __generator(this, function (_b) {
                _a = createSpan("PageBlobClient-startCopyIncremental", options.tracingOptions), span = _a.span, spanOptions = _a.spanOptions;
                try {
                    return [2 /*return*/, this.pageBlobContext.copyIncremental(copySource, {
                            abortSignal: options.abortSignal,
                            modifiedAccessConditions: options.conditions,
                            spanOptions: spanOptions
                        })];
                }
                catch (e) {
                    span.setStatus({
                        code: CanonicalCode.UNKNOWN,
                        message: e.message
                    });
                    throw e;
                }
                finally {
                    span.end();
                }
                return [2 /*return*/];
            });
        });
    };
    return PageBlobClient;
}(BlobClient));
export { PageBlobClient };
//# sourceMappingURL=BlobClient.js.map